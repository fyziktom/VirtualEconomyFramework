<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VEDriversLite</name>
    </assembly>
    <members>
        <member name="T:VEDriversLite.AccountHandler">
            <summary>
            Basic account Handler class
            It can load/add/remove/handle multiple account, use their actions, etc.
            It can use the verification/protection of the calls with the system of the signatures of the messages
            </summary>
        </member>
        <member name="M:VEDriversLite.AccountHandler.VerifyAdminAction(System.String,System.String,System.String)">
            <summary>
            Function will check if the requested action exists and if the signature match
            </summary>
            <param name="admin"></param>
            <param name="signature"></param>
            <param name="message"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:VEDriversLite.AccountHandler.AddEmptyNeblioAccount(VEDriversLite.Admin.Dto.AdminActionBase,System.String,System.Boolean)">
            <summary>
            Function will add new Neblio Account to the VEDLDataContext.Accounts
            </summary>
            <param name="baseInfo"></param>
            <param name="address"></param>
            <param name="verifyActive"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.AccountHandler.AddReadOnlyNeblioAccount(VEDriversLite.Admin.Dto.AdminActionBase,System.String,System.Boolean)">
            <summary>
            Function will add new Neblio Account without Private Key to the VEDLDataContext.Accounts
            Account can be used just for the observation.
            </summary>
            <param name="baseInfo"></param>
            <param name="address"></param>
            <param name="verifyActive"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.AccountHandler.ConnectDogeAccount(VEDriversLite.Admin.Dto.AdminActionBase,VEDriversLite.Admin.Dto.ConnectDogeAccountDto,System.Boolean)">
            <summary>
            Connect Doge account to the Neblio Account
            </summary>
            <param name="baseInfo"></param>
            <param name="dto"></param>
            <param name="verifyActive"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.AccountHandler.DisconnectDogeAccount(VEDriversLite.Admin.Dto.AdminActionBase,VEDriversLite.Admin.Dto.ConnectDogeAccountDto,System.Boolean)">
            <summary>
            Disconnect Doge account from Neblio account
            </summary>
            <param name="baseInfo"></param>
            <param name="dto"></param>
            <param name="verifyActive"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.AccountHandler.LoadVENFTBackup(VEDriversLite.Admin.Dto.AdminActionBase,VEDriversLite.Admin.Dto.EncryptedBackupDto,System.Boolean)">
            <summary>
            Decrypt and oad file from VENFT app to account
            If account already exists, the data is updates.
            If account do not exists, it will create new one and fill with the data
            All accounts are stored in VEDLDataContext static class
            After upload of the data, the local backup file is created. It is ecnrypted with private key, so key.json file is still required for the restart
            </summary>
            <param name="baseInfo"></param>
            <param name="data"></param>
            <param name="verifyActive"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.AccountHandler.RemoveNeblioAccount(VEDriversLite.Admin.Dto.AdminActionBase,System.String,System.Boolean)">
            <summary>
            Remove Neblio Account from the VEDLDataContext.Accounts
            </summary>
            <param name="baseInfo"></param>
            <param name="address"></param>
            <param name="verifyActive"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.AccountHandler.ReloadNFTHashes">
            <summary>
            Reload all NFT Hashes. 
            NFT Hash is shorten version of the NFT hash, just to save space if you have just smaller amount of the NFTs.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.AccountHandler.AddEmptyDogeAccount(VEDriversLite.Admin.Dto.AdminActionBase,System.String,System.Boolean)">
            <summary>
            Add empty Doge Account to the VEDLDataContext.DogeAccounts
            </summary>
            <param name="baseInfo"></param>
            <param name="address"></param>
            <param name="verifyActive"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.AccountHandler.RemoveDogeAccount(VEDriversLite.Admin.Dto.AdminActionBase,System.String,System.Boolean)">
            <summary>
            Remove Doge Account from the VEDLDataContext.DogeAccounts
            </summary>
            <param name="baseInfo"></param>
            <param name="address"></param>
            <param name="verifyActive"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Admin.AdminActionFactory">
            <summary>
            Factory for create Admin Action
            </summary>
        </member>
        <member name="M:VEDriversLite.Admin.AdminActionFactory.GetAdminAction(System.String,VEDriversLite.Admin.Dto.AdminActionTypes,System.String)">
            <summary>
            Get Admin action for access to the Accounts list in the VEDLDataContext.Accounts
            </summary>
            <param name="admin"></param>
            <param name="type"></param>
            <param name="address"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:VEDriversLite.Admin.Dto.AdminActionBase">
            <summary>
            Base parameters for Admin action class
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.AdminActionBase.Admin">
            <summary>
            Neblio Admin Address
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.AdminActionBase.Message">
            <summary>
            Message for sign
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.AdminActionBase.Signature">
            <summary>
            Signature of the message by admin address
            </summary>
        </member>
        <member name="T:VEDriversLite.Admin.Dto.CommonAdminAction">
            <summary>
            Basic implementation of the Admin Action class
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.CommonAdminAction.Data">
            <summary>
            Data for the command/action
            </summary>        
        </member>
        <member name="P:VEDriversLite.Admin.Dto.CommonAdminAction.Type">
            <summary>
            Action type
            </summary>        
        </member>
        <member name="M:VEDriversLite.Admin.Dto.CommonAdminAction.CreateNewMessage">
            <summary>
            Create new message for possibility to sign
            This message is sent to the admin and he must sign it and send back with command
            </summary>
            <returns></returns>        
        </member>
        <member name="T:VEDriversLite.Admin.Dto.ConnectDogeAccountDto">
            <summary>
            Dto for connect Doge account with Neblio Account
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.ConnectDogeAccountDto.adminCredentials">
            <summary>
            Admin credentials info
            Include Admin Address, Message and Signature of this message
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.ConnectDogeAccountDto.dogeAccountAddress">
            <summary>
            Doge Address
            This Address must be already in the VEDLDataContext.DogeAccounts
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.ConnectDogeAccountDto.AccountAddress">
            <summary>
            Neblio Address
            This Address must be already in the VEDLDataContext.Accounts
            </summary>
        </member>
        <member name="T:VEDriversLite.Admin.Dto.EncryptedBackupDto">
            <summary>
            Minimum Dto for backup encrypted account
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.EncryptedBackupDto.eadd">
            <summary>
            Address
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.EncryptedBackupDto.epass">
            <summary>
            Password for Symetric encryption
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.EncryptedBackupDto.edata">
            <summary>
            Encrypted data
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.EncryptedBackupDto.asAdmin">
            <summary>
            Load address as admin address
            </summary>
        </member>
        <member name="T:VEDriversLite.Admin.Dto.AdminActionTypes">
            <summary>
            Type of the Admin action which can be checked before executing the action.
            </summary>
        </member>
        <member name="F:VEDriversLite.Admin.Dto.AdminActionTypes.Common">
            <summary>
            Basic action
            </summary>
        </member>
        <member name="F:VEDriversLite.Admin.Dto.AdminActionTypes.AddNeblioAccount">
            <summary>
            Action for adding Neblio Account
            </summary>
        </member>
        <member name="F:VEDriversLite.Admin.Dto.AdminActionTypes.ImportVENFTBackup">
            <summary>
            Action for load whole VENFT App backup file
            </summary>
        </member>
        <member name="F:VEDriversLite.Admin.Dto.AdminActionTypes.AddDogeAccount">
            <summary>
            Action for load the Dogecoin Account
            </summary>
        </member>
        <member name="T:VEDriversLite.Admin.Dto.IAdminAction">
            <summary>
            Basic interface for Admin Actions
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.IAdminAction.Admin">
            <summary>
            Neblio Admin Address
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.IAdminAction.Message">
            <summary>
            Message for sign
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.IAdminAction.Signature">
            <summary>
            Signature of the message by admin address
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.IAdminAction.Data">
            <summary>
            Data for the command/action
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.IAdminAction.Type">
            <summary>
            Action type
            </summary>
        </member>
        <member name="M:VEDriversLite.Admin.Dto.IAdminAction.CreateNewMessage">
            <summary>
            Create new message for possibility to sign
            This message is sent to the admin and he must sign it and send back with command
            </summary>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Admin.Dto.ImportBackupDto">
            <summary>
            Import basic account Backup Dto
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.ImportBackupDto.adminCredentials">
            <summary>
            Admin credentials info
            Include Admin Address, Message and Signature of this message
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.ImportBackupDto.dto">
            <summary>
            Data dto
            </summary>
        </member>
        <member name="T:VEDriversLite.Admin.Dto.ImportVENFTBackupRequestDto">
            <summary>
            Admin Request for Import of the Backup data
            </summary>
        </member>
        <member name="M:VEDriversLite.Admin.Dto.ImportVENFTBackupRequestDto.#ctor(System.String,System.String)">
            <summary>
            Main constructor.
            </summary>
            <param name="admin"></param>
            <param name="address"></param>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.ImportVENFTBackupRequestDto.Address">
            <summary>
            Address main address of the VENFT Backup
            </summary>
        </member>
        <member name="P:VEDriversLite.Admin.Dto.ImportVENFTBackupRequestDto.BackupData">
            <summary>
            VENFT Backup data serialized to string
            </summary>
        </member>
        <member name="T:VEDriversLite.Bookmarks.ActiveTab">
            <summary>
            Active tab is able to load the Address and its NFTs
            </summary>
        </member>
        <member name="M:VEDriversLite.Bookmarks.ActiveTab.#ctor">
            <summary>
            Basic constructor
            </summary>
        </member>
        <member name="M:VEDriversLite.Bookmarks.ActiveTab.#ctor(System.String)">
            <summary>
            Basic constructor witch will load address and shortaddress
            </summary>
            <param name="address"></param>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.Selected">
            <summary>
            Info if the Tab is selected - this is set by Start or Stop functions internally
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.Address">
            <summary>
            Address loaded in this ActiveTab
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.ShortAddress">
            <summary>
            Shorten version of the address - just help for UI
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.IsInBookmark">
            <summary>
            Flag if the Address is in the bookmark - then it has Bookmark dto loaded
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.CanLoadMore">
            <summary>
            Tab loads just 40 NFTs. if it can load more, this is true
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.IsRefreshingRunning">
            <summary>
            Indicate if the autorefresh is running
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.NFTs">
            <summary>
            List of the loaded NFTs of the Address
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.UtxosList">
            <summary>
            List of the loaded Utxos of the Address
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.BookmarkFromAccount">
            <summary>
            Loaded Bookmark data
            </summary>
        </member>
        <member name="F:VEDriversLite.Bookmarks.ActiveTab.ReceivedPayments">
            <summary>
            Loaded list of the received payments NFTs of the address
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.Profile">
            <summary>
            Profile NFT of the Address
            </summary>
        </member>
        <member name="E:VEDriversLite.Bookmarks.ActiveTab.NFTsChanged">
            <summary>
            This event is called whenever the list of NFTs is changed
            </summary>
        </member>
        <member name="E:VEDriversLite.Bookmarks.ActiveTab.ProfileUpdated">
            <summary>
            This event is called whenever profile nft is updated or found
            </summary>
        </member>
        <member name="E:VEDriversLite.Bookmarks.ActiveTab.FirsLoadingStatus">
            <summary>
            This event is called during first loading of the account to keep updated the user
            </summary>
        </member>
        <member name="E:VEDriversLite.Bookmarks.ActiveTab.NFTAddedToPayments">
            <summary>
            This event is fired whenever some NFT is in received payment too and it should be blocked for any further action.
            It provides Utxo and UtxoIndex as touple.
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.ActiveTab.MaxLoadedNFTItems">
            <summary>
            Limit of the maximum loaded items in the Active Tab
            </summary>
        </member>
        <member name="M:VEDriversLite.Bookmarks.ActiveTab.TxCashPreload">
            <summary>
            This is same function as in NeblioAcocuntBase - TODO merge them to one common function
            This will make loading of the tab much faster
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Bookmarks.ActiveTab.StartRefreshing(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Start Automated refreshing
            </summary>
            <param name="interval">basic refresh interval</param>
            <param name="withoutMessages">dont load the NFT Messages</param>
            <param name="withCahePreload">Activate preload</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Bookmarks.ActiveTab.StopRefreshing">
            <summary>
            Stop automated refreshing
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Bookmarks.ActiveTab.Reload(System.Boolean)">
            <summary>
            Reload Address Utxos and refresh the NFT list
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Bookmarks.ActiveTab.RefreshAddressReceivedPayments">
            <summary>
            This function will search NFT Payments in the NFTs list and load them into ReceivedPayments list. 
            This list is cleared at the start of this function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Bookmarks.ActiveTab.LoadBookmark(VEDriversLite.Bookmarks.Bookmark)">
            <summary>
            Load Bookmark data into ActiveTab class when some bookmark is found in another storage (for example NeblioAccount class)
            </summary>
            <param name="bkm"></param>
        </member>
        <member name="M:VEDriversLite.Bookmarks.ActiveTab.ClearBookmark">
            <summary>
            Clear the Bookmark data in ActiveTab
            </summary>
        </member>
        <member name="T:VEDriversLite.Bookmarks.Bookmark">
            <summary>
            Bookmark with saved blockchain Address, name and description
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.Bookmark.Name">
            <summary>
            Name of the bookmark
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.Bookmark.Address">
            <summary>
            Blockchain address of the Bookmark
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.Bookmark.Note">
            <summary>
            Note about bookmark
            </summary>
        </member>
        <member name="P:VEDriversLite.Bookmarks.Bookmark.IsSubAccount">
            <summary>
            If this is true, the bookmark is on some subaccount
            </summary>
        </member>
        <member name="T:VEDriversLite.CommonReturnTypeDto">
            <summary>
            This class is to declare the common method return type used mostly in helper classes. To generalize the return data we have added this class.
            </summary>
        </member>
        <member name="P:VEDriversLite.CommonReturnTypeDto.Success">
            <summary>
            This property tells whether the return type is a success or a failure
            </summary>
        </member>
        <member name="P:VEDriversLite.CommonReturnTypeDto.Value">
            <summary>
            This property holds the actual value
            </summary>
        </member>
        <member name="T:VEDriversLite.StringExt">
            <summary>
            Extend of the String functions
            </summary>
        </member>
        <member name="M:VEDriversLite.StringExt.Truncate(System.String,System.Int32)">
            <summary>
            Turncate the string to some max length
            </summary>
            <param name="value"></param>
            <param name="maxLength"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.StringExt.ZipStr(System.String)">
            <summary>
            https://stackoverflow.com/questions/2118904/zip-and-unzip-string-with-deflate
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.StringExt.UnZipStr(System.Byte[])">
            <summary>
            https://stackoverflow.com/questions/2118904/zip-and-unzip-string-with-deflate
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.FileHelpers">
            <summary>
            Helper class for handle the files
            </summary>
        </member>
        <member name="M:VEDriversLite.FileHelpers.ClearEmptyDirs(System.String)">
            <summary>
            Remove all the empty folders in the main folder
            </summary>
            <param name="DataFolder">Main folder address</param>
        </member>
        <member name="M:VEDriversLite.FileHelpers.CopyFile(System.String,System.String)">
            <summary>
            Copy file from one to another destionation
            </summary>
            <param name="sourceFilePath">Input file destionation</param>
            <param name="destinatinFilePath">Final file destination</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.FileHelpers.GetDateTimeString">
            <summary>
            short datetime string...todo use formating in ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.FileHelpers.GetTimeString">
            <summary>
            short time string...todo use formating in ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.FileHelpers.GetDateString">
            <summary>
            short date string...todo use formating in ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.FileHelpers.CheckOrCreateTheFolder(System.String,System.String,System.Boolean)">
            <summary>
            Check if the folder exists in the inputed location. If not exists, it will create it
            The new folder name can contains the automatic datetime stamp and optional suffix
            </summary>
            <param name="_outputFolderPath">The path to check</param>
            <param name="suffix">Sufix for the new folder</param>
            <param name="withdatetime">If you want to add datetime stamp automatically</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.FileHelpers.AppendLineToTextFile(System.String,System.String)">
            <summary>
            Add line to the end of some file.
            If the file does not exists it will create the new file.
            </summary>
            <param name="line">New line which should be added to the file</param>
            <param name="outputPath">Output path of the file</param>
        </member>
        <member name="M:VEDriversLite.FileHelpers.WriteTextToFile(System.String,System.String)">
            <summary>
            Write whole text into the file.
            If the file does not exists it will create the new file.
            </summary>
            <param name="path">Output path of the file</param>
            <param name="content">content text</param>
        </member>
        <member name="M:VEDriversLite.FileHelpers.ReadTextFromFile(System.String)">
            <summary>
            Read all the text from the file
            </summary>
            <param name="path">Path of the input file</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.FileHelpers.IsFileExists(System.String)">
            <summary>
            Check if the file exists
            </summary>
            <param name="path">Path of the file</param>
            <returns>true if the file exists</returns>
        </member>
        <member name="T:VEDriversLite.Common.RegexMatchPaterns">
            <summary>
            Common patterns for Regex
            </summary>
        </member>
        <member name="P:VEDriversLite.Common.RegexMatchPaterns.EmojiPattern">
            <summary>
            This pattern identify the emojis in the text
            </summary>
        </member>
        <member name="T:VEDriversLite.Common.QTWalletRPC">
            <summary>
            QT Wallet RPC client controler
            </summary>
        </member>
        <member name="F:VEDriversLite.Common.QTWalletRPC.ApiFunctions">
            <summary>
            Main API functions
            </summary>
        </member>
        <member name="M:VEDriversLite.Common.QTWalletRPC.ProcessRequest(System.String,System.String,System.String[],VEDriversLite.NeblioAPI.JsonClient)">
            <summary>
            Find match for command in ApiDictionary and invoke function
            </summary>
            <param name="uid">Request UID</param>
            <param name="command">Command to do</param>
            <param name="args">set of arguments</param>
            <param name="jsonClient"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Common.QTWalletRPC.CommonMultipleParameterRequest(System.String,System.String,System.String[],VEDriversLite.NeblioAPI.JsonClient)">
            <summary>
            Common Api Function - Common call for command with multiple parameter
            </summary>
            <param name="uid"></param>
            <param name="command"></param>
            <param name="args"></param>
            <param name="jsonClient"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Common.QTWalletRPC.CommonOneParameterRequest(System.String,System.String,System.String[],VEDriversLite.NeblioAPI.JsonClient)">
            <summary>
            Common Api Function - Common call for command with one parameter
            </summary>
            <param name="uid"></param>
            <param name="command"></param>
            <param name="args"></param>
            <param name="jsonClient"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Common.QTWalletRPC.CommonNoParameterRequest(System.String,System.String,System.String[],VEDriversLite.NeblioAPI.JsonClient)">
            <summary>
            Common Api Function - Common request without parameter
            </summary>
            <param name="uid"></param>
            <param name="command"></param>
            <param name="args"></param>
            <param name="jsonClient"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Common.QTWalletRPCClient.RPCLocalCommandAsync(System.String,System.Object)">
            <summary>
            Function for call of RPC command. Parameters is string splitted with ','
            First is command, then goes the parameters. If parameters must cointain ',' please use function RPCLocalCommandSplitedAsync
            </summary>
            <param name="param">First is command, then goes the parameters.</param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Common.QTWalletRPCClient.RPCLocalCommandSplitedAsync(System.String,System.String[])">
            <summary>
            This function require already splitted command and parameters
            This is for the case that some of the parameters must contain ',' which is used as separator
            </summary>
            <param name="command">RPC command name</param>
            <param name="parameters">string array of parameters</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.TimeHelpers">
            <summary>
            Time helpers to convert time between UnixTimeStamp and classic time
            https://stackoverflow.com/questions/249760/how-can-i-convert-a-unix-timestamp-to-datetime-and-vice-versa
            </summary>
        </member>
        <member name="M:VEDriversLite.TimeHelpers.UnixTimestampToDateTime(System.Double)">
            <summary>
            Convert Unix Time stamp in miliseconds to DateTime
            </summary>
            <param name="unixTime">timestamp in miliseconds</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.TimeHelpers.DateTimeToUnixTimestamp(System.DateTime)">
            <summary>
            Convert DateTime to Unix timestamp in miliseconds
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Devices.APIs.HARDWARIO.Dto.Acceleration">
            <summary>
            Dto for HARDWARIO CHESTER data about acceleration
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.Acceleration.axis_x">
            <summary>
            X Axis Data
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.Acceleration.axis_y">
            <summary>
            Y Axis Data
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.Acceleration.axis_z">
            <summary>
            Z Axis data
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWAccelerometer">
            <summary>
            Dto for HARDWARIO CHESTER data about acceleration
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWAccelerometer.acceleration">
            <summary>
            Data about axceleration
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWAccelerometer.orientation">
            <summary>
            Orientation of the accelerometer
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDataDto">
            <summary>
            Dto for HARDWARIO CHESTER data
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDataDto.tracking">
            <summary>
            Tracking data from CHESTER Gateway
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDataDto.sensor">
            <summary>
            Sensor data
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDto">
            <summary>
            Dto for HARDWARIO CHESTER data about hardware
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDto.id">
            <summary>
            ID of the CHESTER device message
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDto.created_at">
            <summary>
            Message created at utc time
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDto.group_id">
            <summary>
            Group Id where device is
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDto.device_id">
            <summary>
            CHESTER Device Id
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDto.organization_id">
            <summary>
            Organization Id where device is
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDto.label">
            <summary>
            Label of the device
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDto.name">
            <summary>
            Name of the device
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWDto.data">
            <summary>
            Message data
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWSensor">
            <summary>
            Dto for HARDWARIO CHESTER data about sensor
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWSensor.thermometer">
            <summary>
            Thermometer sensor data
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWSensor.accelerometer">
            <summary>
            Accelerometer sensor data
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWThermometer">
            <summary>
            Dto for HARDWARIO CHESTER data about thermometer
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.HWThermometer.temperature">
            <summary>
            Temperature on the sensor
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.APIs.HARDWARIO.Dto.TrackingInfo">
            <summary>
            Dto for HARDWARIO CHESTER data about position and tracking
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.TrackingInfo.time">
            <summary>
            Time of grabbed location
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.TrackingInfo.latitude">
            <summary>
            Latitude location coordinant
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.Dto.TrackingInfo.longitude">
            <summary>
            Longitude location coordinant
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.APIs.HARDWARIO.HARDWARIOApiClient">
            <summary>
            API Client for the HARDWARIO Cloud API
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.APIs.HARDWARIO.HARDWARIOApiClient.CommonConnParams">
            <summary>
            Common connection properties like Url, security, etc.
            </summary>
        </member>
        <member name="M:VEDriversLite.Devices.APIs.HARDWARIO.HARDWARIOApiClient.SetCommonConnectionParameters(VEDriversLite.Devices.Dto.CommonConnectionParams)">
            <summary>
            Load the connection parameters
            </summary>
            <param name="ccop"></param>
        </member>
        <member name="M:VEDriversLite.Devices.APIs.HARDWARIO.HARDWARIOApiClient.GetClient(System.String)">
            <summary>
            Create Client for connection with the API token
            </summary>
            <param name="apitoken"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Devices.APIs.HARDWARIO.HARDWARIOApiClient.GetMessages(System.String,System.String,System.String)">
            <summary>
            Get message from the API for specific device
            </summary>
            <param name="deviceid">Device Id</param>
            <param name="group">Group Id</param>
            <param name="apitoken">API token for communication with HARDWARIO Cloud</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Devices.APIs.HARDWARIO.HARDWARIOApiClient.GetUnreadedMessage(System.String,System.String,System.String)">
            <summary>
            Get undread message
            </summary>
            <param name="deviceid"></param>
            <param name="group"></param>
            <param name="apitoken"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Devices.APIs.HARDWARIO.HARDWARIOApiClient.ConfirmReadOfMessage(System.String,System.String,System.String,System.String)">
            <summary>
            confirm readed message - TODO: some bug, api not respond correctly
            </summary>
            <param name="deviceid"></param>
            <param name="group"></param>
            <param name="messageid"></param>
            <param name="apitoken"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Devices.CommonIoTDataDriver">
            <summary>
            Common base for the IoTDataDrivers
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.CommonIoTDataDriver.Name">
            <summary>
            Name of the driver
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.CommonIoTDataDriver.Type">
            <summary>
            Driver type
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.CommonIoTDataDriver.ComSchemeType">
            <summary>
            Communication Schemes (Requests - classic API), (PubSub - like MQTT)
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.CommonIoTDataDriver.IoTComType">
            <summary>
            Communication type - REST API, MSSQL Database, MQTT, etc.
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.CommonIoTDataDriver.CommonConnParams">
            <summary>
            Main connection parameters
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.CommonIoTDataDriver.CancelTokenSource">
            <summary>
            Cancelation token source for the cancel of automatic loading of the messages
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.CommonIoTDataDriver.CancelToken">
            <summary>
            Cancelation token for the cancel of automatic loading of the messages
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.CommonIoTDataDriver.IsRunning">
            <summary>
            Is the Driver running - means autorefresh of the messages
            </summary>
        </member>
        <member name="E:VEDriversLite.Devices.CommonIoTDataDriver.NewDataReceived">
            <summary>
            New message found
            </summary>
        </member>
        <member name="M:VEDriversLite.Devices.CommonIoTDataDriver.Init(VEDriversLite.NFT.INFT)">
            <summary>
            Init driver communication - means autorefresh of the messages
            </summary>
            <param name="nft"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Devices.CommonIoTDataDriver.DeInit">
            <summary>
            Deinit driver communiation - means autorefresh of the messages
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Devices.CommonIoTDataDriver.SetConnParams(VEDriversLite.Devices.Dto.CommonConnectionParams)">
            <summary>
            Set connection parameters
            </summary>
            <param name="ccop"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Devices.Dto.CommunitacionSecurityType">
            <summary>
            Security of the API
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.Dto.CommunitacionSecurityType.None">
            <summary>
            Without credentials
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.Dto.CommunitacionSecurityType.SSL">
            <summary>
            SSL classic user and pass
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.Dto.CommunitacionSecurityType.Bearer">
            <summary>
            common Bearer token
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.Dto.CommunitacionSecurityType.JWT">
            <summary>
            JWT Token
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.Dto.CommonConnectionParams">
            <summary>
            Main connection parameters for the IoT data driver to access the API
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.IP">
            <summary>
            IP for connection
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.Url">
            <summary>
            URL for connection
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.Port">
            <summary>
            PORT for connection
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.Encrypted">
            <summary>
            Is communication encrypted
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.Secured">
            <summary>
            is commection secured
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.SType">
            <summary>
            Type of security type like: SSL, Bearer, etc.
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.Username">
            <summary>
            User name for the case of secured connection
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.Password">
            <summary>
            Password name for the case of secured connection
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.Token">
            <summary>
            Token for the case of secured connection
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.GroupId">
            <summary>
            Group Id of the device
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.DeviceId">
            <summary>
            Device Id of the device
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.UserId">
            <summary>
            User Id of the owner of the device
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.CommonConnectionParams.CommonRefreshInterval">
            <summary>
            Common data refresh interval in miliseconds
            Default value is 10s = 10000ms
            This is usually used for request type of the communication
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.Dto.IoTDataDriverSettings">
            <summary>
            Settings of the IoT data driver. Most of the settings are for connection to the API or source of the data
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.IoTDataDriverSettings.ComSchemeType">
            <summary>
            Communication Schemes (Requests - classic API), (PubSub - like MQTT)
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.IoTDataDriverSettings.IoTComType">
            <summary>
            Communication type - REST API, MSSQL Database, MQTT, etc.
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.Dto.IoTDataDriverSettings.ConnectionParams">
            <summary>
            Main connection parameters
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.HARDWARIOIoTDataDriver">
            <summary>
            Data driver to obtain data from the HARDWARIO Cloud API
            Can be used primarly for the CHESTER devices
            </summary>
        </member>
        <member name="E:VEDriversLite.Devices.HARDWARIOIoTDataDriver.NewDataReceived">
            <summary>
            New data on the API
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.HARDWARIOIoTDataDriver.HWApiClient">
            <summary>
            Main client
            </summary>
        </member>
        <member name="M:VEDriversLite.Devices.HARDWARIOIoTDataDriver.DeInit">
            <summary>
            Deinit driver communiation - means autorefresh of the messages
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Devices.HARDWARIOIoTDataDriver.Init(VEDriversLite.NFT.INFT)">
            <summary>
            Init driver communication - means autorefresh of the messages
            </summary>
            <param name="nft"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Devices.HARDWARIOIoTDataDriver.SetConnParams(VEDriversLite.Devices.Dto.CommonConnectionParams)">
            <summary>
            Set connection parameters
            </summary>
            <param name="ccop"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Devices.IoTDataDriverType">
            <summary>
            Type of the IoT Data Drivers
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTDataDriverType.Common">
            <summary>
            Not specified
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTDataDriverType.HARDWARIO">
            <summary>
            Hardwario IoT platform
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTDataDriverType.PLFramework">
            <summary>
            PLFramework platform
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTDataDriverType.M5Stack">
            <summary>
            M5Stack IoT platform
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.CommunicationSchemeType">
            <summary>
            Scheme of the communication
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.CommunicationSchemeType.Requests">
            <summary>
            Request to API
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.CommunicationSchemeType.PubSub">
            <summary>
            Publisher Subscriber model - for example MQTT
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.IoTCommunicationType">
            <summary>
            Communication type
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTCommunicationType.API">
            <summary>
            API access
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTCommunicationType.File">
            <summary>
            File storage
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTCommunicationType.DbMSSQL">
            <summary>
            Database Microsoft SQL
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTCommunicationType.DbPostgreSQL">
            <summary>
            Database PostgreSQL
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTCommunicationType.DbSQLite">
            <summary>
            Database SQLite
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTCommunicationType.MQTT">
            <summary>
            MQTT protocol
            </summary>
        </member>
        <member name="F:VEDriversLite.Devices.IoTCommunicationType.OPCUA">
            <summary>
            OPC UA protocol
            </summary>
        </member>
        <member name="T:VEDriversLite.Devices.IIoTDataDriver">
            <summary>
            Basic interface for IoT Data Driver
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.IIoTDataDriver.Name">
            <summary>
            Name of the driver
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.IIoTDataDriver.Type">
            <summary>
            Driver type
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.IIoTDataDriver.ComSchemeType">
            <summary>
            Communication Schemes (Requests - classic API), (PubSub - like MQTT)
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.IIoTDataDriver.IoTComType">
            <summary>
            Communication type - REST API, MSSQL Database, MQTT, etc.
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.IIoTDataDriver.CommonConnParams">
            <summary>
            Main connection parameters
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.IIoTDataDriver.CancelTokenSource">
            <summary>
            Cancelation token source for the cancel of automatic loading of the messages
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.IIoTDataDriver.CancelToken">
            <summary>
            Cancelation token for the cancel of automatic loading of the messages
            </summary>
        </member>
        <member name="P:VEDriversLite.Devices.IIoTDataDriver.IsRunning">
            <summary>
            Is the Driver running - means autorefresh of the messages
            </summary>
        </member>
        <member name="E:VEDriversLite.Devices.IIoTDataDriver.NewDataReceived">
            <summary>
            New message found
            </summary>
        </member>
        <member name="M:VEDriversLite.Devices.IIoTDataDriver.Init(VEDriversLite.NFT.INFT)">
            <summary>
            Init driver communication - means autorefresh of the messages
            </summary>
            <param name="nft"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Devices.IIoTDataDriver.DeInit">
            <summary>
            Deinit driver communiation - means autorefresh of the messages
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Devices.IIoTDataDriver.SetConnParams(VEDriversLite.Devices.Dto.CommonConnectionParams)">
            <summary>
            Set connection parameters
            </summary>
            <param name="ccop"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Devices.IoTDataDriverFactory">
            <summary>
            Factory for IoT Data Drivers
            </summary>
        </member>
        <member name="M:VEDriversLite.Devices.IoTDataDriverFactory.GetIoTDataDriver(VEDriversLite.Devices.IoTDataDriverType)">
            <summary>
            Return correct IoT Data Driver based on the selected type
            It supports now just HARDWARIO IoT Data Driver
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.DogeAccount">
            <summary>
            Main Dogecoin Account class
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.Address">
            <summary>
            Doge Address hash
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.Secret">
            <summary>
            Loaded Secret, NBitcoin Class which carry Public Key and Private Key
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.BAddress">
            <summary>
            Address in form of BitcoinAddress object
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.TotalBalance">
            <summary>
            Total actual balance based on Utxos. This means sum of spendable and unconfirmed balances.
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.TotalSpendableBalance">
            <summary>
            Total spendable balance based on Utxos.
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.TotalUnconfirmedBalance">
            <summary>
            Total balance which is now unconfirmed based on Utxos.
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.Utxos">
            <summary>
            Actual list of all Utxos on this address.
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.SentTransactions">
            <summary>
            Actual list of last 100 Spended transactions on this address.
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.ReceivedTransactions">
            <summary>
            Actual list of last 100 Received transactions on this address.
            </summary>
        </member>
        <member name="E:VEDriversLite.DogeAccount.Refreshed">
            <summary>
            This event is called whenever info about the address is reloaded. It is periodic event.
            </summary>
        </member>
        <member name="E:VEDriversLite.DogeAccount.NewEventInfo">
            <summary>
            This event is called whenever some important thing happen. You can obtain success, error and info messages.
            </summary>
        </member>
        <member name="E:VEDriversLite.DogeAccount.NewDogeUtxos">
            <summary>
            This event is called whenever new doge transaction is received
            </summary>
        </member>
        <member name="P:VEDriversLite.DogeAccount.AccountKey">
            <summary>
            Carrier for encrypted private key from storage and its password.
            </summary>
        </member>
        <member name="M:VEDriversLite.DogeAccount.IsLocked">
            <summary>
            This function will check if the account is locked or unlocked.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.InvokeSendPaymentSuccessEvent(System.String,System.String)">
            <summary>
            Invoke Success message info event
            </summary>
            <param name="txid">new tx id hash</param>
            <param name="title">Title of the event message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.InvokeAccountLockedEvent(System.String)">
            <summary>
            Invoke Error message because account is locked
            </summary>
            <param name="title">Title of the event message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.InvokeErrorDuringSendEvent(System.String,System.String)">
            <summary>
            Invoke Error message which occured during sending of the transaction
            </summary>
            <param name="errorMessage">Error message content</param>
            <param name="title">Title of the event message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.InvokeErrorEvent(System.String,System.String)">
            <summary>
            Invoke Common Error message
            </summary>
            <param name="errorMessage">Error message content</param>
            <param name="title">Title of the event message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.CreateNewAccount(System.String,System.Boolean)">
            <summary>
            This function will create new account - Doge address and its Private key.
            </summary>
            <param name="password">Input password, which will encrypt the Private key</param>
            <param name="saveToFile">if you want to save it to the file (dont work in the WASM) set this. It will save to root exe path as key.txt</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.LoadAccount(System.String,System.String)">
            <summary>
            Load account from "key.txt" file placed in the root exe directory. Doesnt work in WABS
            </summary>
            <param name="password">Passwotd to decrypt the loaded private key</param>
            <param name="filename">Filename with the key. Default name is dogekey.txt</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.LoadAccount(System.String,System.String,System.String)">
            <summary>
            Load account from password, input encrypted private key and address.
            It expect the private key is encrypted by the password.
            It uses AES encryption
            </summary>
            <param name="password"></param>
            <param name="encryptedKey"></param>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.LoadAccountWithDummyKey(System.String)">
            <summary>
            Load account just for observation
            You cannot sign tx when you load address this way
            </summary>
            <param name="address">Address</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.StartRefreshingData(System.Int32)">
            <summary>
            This function will load the actual data and then run the task which periodically refresh this data.
            It doesnt have cancellation now!
            </summary>
            <param name="interval">Default interval is 3000 = 3 seconds</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.ReloadUtxos">
            <summary>
            Reload address Utxos list. It will sort descending the utxos based on the utxos number of confirmations.
            Smallest number of confirmations leads to newest transations
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.GetListOfSentTransactions">
            <summary>
            This function will get list of spended transaction
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.GetListOfReceivedTransactions">
            <summary>
            This function will get list of received transaction
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.CheckSpendableDoge(System.Double)">
            <summary>
            This function will check if there is some spendable doge of specific amount and returns list of the utxos for the transaction
            </summary>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.SendPayment(System.String,System.Double,System.String,System.String,System.Int32)">
            <summary>
            Send Doge payment
            </summary>
            <param name="receiver">Receiver Doge Address</param>
            <param name="amount">Ammount in Doge</param>
            <param name="message">add message to OP_RETURN data. max 83 bytes</param>
            <param name="utxo">from specific utxo</param>
            <param name="N">with specific utxo index</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.SendMultipleInputPayment(System.String,System.Double,System.Collections.Generic.List{VEDriversLite.DogeAPI.Utxo},System.String,System.UInt64)">
            <summary>
            Send Doge payment with multiple inputs
            </summary>
            <param name="receiver">Receiver Doge Address</param>
            <param name="amount">Ammount in Doge</param>
            <param name="utxos"></param>
            <param name="message"></param>
            <param name="fee"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.SendMultipleOutputPayment(System.Collections.Generic.Dictionary{System.String,System.Double},System.Collections.Generic.List{VEDriversLite.DogeAPI.Utxo},System.String)">
            <summary>
            Send Doge payment with multiple outputs
            </summary>
            <param name="receiverAmounts"></param>
            <param name="utxos"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.BuyNFT(System.String,System.String,VEDriversLite.NFT.INFT)">
            <summary>
            Buy the NFT based on the NFT and Neblio Address
            </summary>
            <param name="neblioAddress"></param>
            <param name="receiver"></param>
            <param name="nft"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.SignMessage(System.String)">
            <summary>
            Sign custom message with use of account Private Key
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAccount.VerifyMessage(System.String,System.String,System.String)">
            <summary>
            Verify message which was signed by some address.
            </summary>
            <param name="message">Input message</param>
            <param name="signature">Signature of this message created by owner of some doge address.</param>
            <param name="address">Doge address which should sign the message and should be verified.</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetAddressBalanceAsync(System.String)">
            <summary>Returns the doge balance</summary>
            <param name="address">Doge address</param>
            <returns>Object containing doge balance, if address symbol does not exist on network, empty object is returned.</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetAddressBalanceAsync(System.String,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Returns the doge balance</summary>
            <param name="address">Doge address</param>
            <returns>Object containing doge balance, if address symbol does not exist on network, empty object is returned.</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetTransactionInfoAsync(System.String)">
            <summary>Information On an Doge Transaction</summary>
            <param name="txid">Doge txid to get information on.</param>
            <returns>An object represending this transaction</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetTransactionInfoAsync(System.String,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Information On an Doge Transaction</summary>
            <param name="txid">Doge txid to get information on.</param>
            <returns>An object represending this transaction</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetAddressUtxosAsync(System.String)">
            <summary>Doge Address Unspended transactions</summary>
            <param name="address">Doge Address</param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetAddressUtxosAsync(System.String,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Doge Address Unspended transactions</summary>
            <param name="address">Doge Address</param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetAddressSentTxAsync(System.String)">
            <summary>Doge Address spended transactions</summary>
            <param name="address">Doge Address</param>
            <returns>Object containing collection of Spended transactions</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetAddressSentTxAsync(System.String,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Doge Address Unspended transactions</summary>
            <param name="address">Doge Address</param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetAddressReceivedTxAsync(System.String)">
            <summary>Doge Address received transactions</summary>
            <param name="address">Doge Address</param>
            <returns>Object containing collection of Spended transactions</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.GetAddressReceivedTxAsync(System.String,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Doge Address Unspended transactions</summary>
            <param name="address">Doge Address</param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.BroadcastTxAsync(VEDriversLite.DogeAPI.BroadcastTxRequest)">
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.BroadcastTxAsync(VEDriversLite.DogeAPI.BroadcastTxRequest,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.ChainSoBroadcastTxAsync(VEDriversLite.DogeAPI.ChainSoBroadcastTxRequest)">
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.ChainSoBroadcastTxAsync(VEDriversLite.DogeAPI.ChainSoBroadcastTxRequest,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.VENFTBroadcastTxAsync(VEDriversLite.DogeAPI.VENFTBroadcastTxRequest)">
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.Client.VENFTBroadcastTxAsync(VEDriversLite.DogeAPI.VENFTBroadcastTxRequest,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IJsonClient.RpcAsync(VEDriversLite.DogeAPI.RpcRequest)">
            <summary>Send a JSON-RPC call to a localhost neblio-Qt or nebliod node</summary>
            <returns>Object containing the JSON response from the Neblio node.</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IJsonClient.RpcAsync(VEDriversLite.DogeAPI.RpcRequest,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Send a JSON-RPC call to a localhost neblio-Qt or nebliod node</summary>
            <returns>Object containing the JSON response from the Neblio node.</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.JsonClient.RpcAsync(VEDriversLite.DogeAPI.RpcRequest)">
            <summary>Send a JSON-RPC call to a localhost neblio-Qt or nebliod node</summary>
            <returns>Object containing the JSON response from the Neblio node.</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.JsonClient.RpcAsync(VEDriversLite.DogeAPI.RpcRequest,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Send a JSON-RPC call to a localhost neblio-Qt or nebliod node</summary>
            <returns>Object containing the JSON response from the Neblio node.</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressBalanceResponse.Status">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressBalanceResponse.Data">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressBalanceResponseData.Network">
            <summary>Balance on the address</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressBalanceResponseData.Address">
            <summary>Balance on the address</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressBalanceResponseData.Balance">
            <summary>Balance on the address</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressBalanceResponseData.UnconfirmedBalance">
            <summary>Balance on the address</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressUtxosResponse.Status">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressUtxosResponse.Data">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressUtxosResponseData.network">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressUtxosResponseData.address">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressUtxosResponseData.Utxos">
            <summary>Array of transaction outputs</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Utxo.TxId">
            <summary>TxId hash</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Utxo.Script">
            <summary>Script signature</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Utxo.ScriptHex">
            <summary>Script signature</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Utxo.N">
            <summary>Index of the output</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Utxo.Value">
            <summary>Value in satoshi</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Utxo.Confirmations">
            <summary>Number of confirmaions</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Utxo.Time">
            <summary>Number of confirmaions</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressSpentTxsResponse.Status">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressSpentTxsResponse.Data">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressSpentTxsResponseData.network">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressSpentTxsResponseData.address">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressSpentTxsResponseData.Transactions">
            <summary>Array of transaction outputs</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.SpentTx.TxId">
            <summary>TxId hash</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.SpentTx.Script">
            <summary>Script signature</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.SpentTx.ScriptHex">
            <summary>Script signature</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.SpentTx.N">
            <summary>Index of the output</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.SpentTx.Value">
            <summary>Value in satoshi</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.SpentTx.Confirmations">
            <summary>Number of confirmaions</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.SpentTx.Time">
            <summary>Number of confirmaions</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressReceivedTxsResponse.Status">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressReceivedTxsResponse.Data">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressReceivedTxsResponseData.network">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressReceivedTxsResponseData.address">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetAddressReceivedTxsResponseData.Transactions">
            <summary>Array of transaction outputs</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ReceivedTx.TxId">
            <summary>TxId hash</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ReceivedTx.Script">
            <summary>Script signature</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ReceivedTx.ScriptHex">
            <summary>Script signature</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ReceivedTx.N">
            <summary>Index of the output</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ReceivedTx.Value">
            <summary>Value in satoshi</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ReceivedTx.Confirmations">
            <summary>Number of confirmaions</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ReceivedTx.Time">
            <summary>Number of confirmaions</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.BroadcastTxRequest.data">
            <summary>Signed raw tx hex to broadcast</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ChainSoBroadcastTxRequest.tx_hex">
            <summary>Signed raw tx hex to broadcast</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.VENFTBroadcastTxRequest.network">
            <summary>Signed raw tx hex to broadcast</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.VENFTBroadcastTxRequest.tx_hex">
            <summary>Signed raw tx hex to broadcast</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.BroadcastTxResponse.Data">
            <summary>Txid of successfully broadcasted transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ChainSoBroadcastTxResponse.Network">
            <summary>Txid of successfully broadcasted transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.ChainSoBroadcastTxResponse.TxId">
            <summary>Txid of successfully broadcasted transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.BTData.TxId">
            <summary>Txid of successfully broadcasted transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.BroadcastTxResponseData.TxId">
            <summary>Txid of successfully broadcasted transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.BroadcastTxResponseData.Network">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetTransactionInfoResponse.Success">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.GetTransactionInfoResponse.Transaction">
            <summary>Transaction object</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.Txid">
            <summary>TxId of transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.Network">
            <summary>TxId of transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.BlockHash">
            <summary>Blockhash of transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.TxHex">
            <summary>Blockhash of transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.Version">
            <summary>Transaction version</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.Locktime">
            <summary>Transaction locktime</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.Vin">
            <summary>Array of transaction inputs</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.Vout">
            <summary>Array of transaction outputs</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.Time">
            <summary>Block time of this transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.Size">
            <summary>Block height of this transaction</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.TransactionResponseObject.Confirmations">
            <summary>Number of transaction confirmations</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Vin.Addr">
            <summary> Sender Address </summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Vin.ScriptSig">
            <summary> Sender Script signature </summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Vin.N">
            <summary>Value of input in Doge satoshi</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Vin.Value">
            <summary>Value of input in Doge satoshi</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.PreviousOutput.TxId">
            <summary> Previous output TxId hash </summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.PreviousOutput.N">
            <summary> Previous output index </summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Vout.Value">
            <summary>Value of the output in Doge satoshi</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Vout.N">
            <summary>Output index</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Vout.Address">
            <summary> Receiver Address </summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.Vout.Script">
            <summary> Receiver Address </summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.RpcRequest.Jsonrpc">
            <summary>JSON-RPC version</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.RpcRequest.Id">
            <summary>Identifier of RCP caller</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.RpcRequest.Method">
            <summary>Name of the Neblio RPC method to call</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.RpcRequest.Params">
            <summary>Array of string params that should be passed to the RPC method.</summary>
        </member>
        <member name="T:VEDriversLite.DogeAPI.RpcResponse">
            <summary>Object containing the JSON response from the Neblio node.</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.RpcResponse.Result">
            <summary>Object containing the response output.</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.RpcResponse.Id">
            <summary>Identifier of RCP caller</summary>
        </member>
        <member name="P:VEDriversLite.DogeAPI.RpcResponse.Error">
            <summary>Object containing any error information.</summary>
        </member>
        <member name="T:VEDriversLite.DogeAPI.IClient">
            <summary>
            Doge API common client interface
            </summary>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetAddressBalanceAsync(System.String)">
            <summary>Returns the doge balance</summary>
            <param name="address">Doge address</param>
            <returns>Object containing doge balance, if address symbol does not exist on network, empty object is returned.</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetAddressBalanceAsync(System.String,System.Threading.CancellationToken)">
            <summary>Returns the doge balance</summary>
            <param name="address">Doge address</param>
            <param name="cancellationToken"></param>
            <returns>Object containing doge balance, if address symbol does not exist on network, empty object is returned.</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.BroadcastTxAsync(VEDriversLite.DogeAPI.BroadcastTxRequest)">
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.BroadcastTxAsync(VEDriversLite.DogeAPI.BroadcastTxRequest,System.Threading.CancellationToken)">
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <param name="cancellationToken"></param>
            <param name="body"></param>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.ChainSoBroadcastTxAsync(VEDriversLite.DogeAPI.ChainSoBroadcastTxRequest)">
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <param name="body"></param>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.ChainSoBroadcastTxAsync(VEDriversLite.DogeAPI.ChainSoBroadcastTxRequest,System.Threading.CancellationToken)">
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <param name="body"></param>
            <param name="cancellationToken"></param>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.VENFTBroadcastTxAsync(VEDriversLite.DogeAPI.VENFTBroadcastTxRequest)">
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <param name="body"></param>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.VENFTBroadcastTxAsync(VEDriversLite.DogeAPI.VENFTBroadcastTxRequest,System.Threading.CancellationToken)">
            <summary>Broadcasts a signed raw transaction to the network</summary>
            <param name="body"></param>
            <param name="cancellationToken"></param>
            <returns>An object containing the TXID if the broadcast was successful</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetTransactionInfoAsync(System.String)">
            <summary>Information On an Doge Transaction</summary>
            <param name="txid">Doge txid to get information on.</param>
            <returns>An object represending this transaction</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetTransactionInfoAsync(System.String,System.Threading.CancellationToken)">
            <summary>Information On an Doge Transaction</summary>
            <param name="txid">Doge txid to get information on.</param>
            <param name="cancellationToken"></param>
            <returns>An object represending this transaction</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetAddressUtxosAsync(System.String)">
            <summary>Doge Address Unspended transactions</summary>
            <param name="address">Doge Address</param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetAddressUtxosAsync(System.String,System.Threading.CancellationToken)">
            <summary>Doge Address Unspended transactions</summary>
            <param name="address">Doge Address</param>
            <param name="cancellationToken"></param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetAddressSentTxAsync(System.String)">
            <summary>Doge Address spended transactions</summary>
            <param name="address">Doge Address</param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetAddressSentTxAsync(System.String,System.Threading.CancellationToken)">
            <summary>Doge Address spended transactions</summary>
            <param name="address">Doge Address</param>
            <param name="cancellationToken"></param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetAddressReceivedTxAsync(System.String)">
            <summary>Doge Address spended transactions</summary>
            <param name="address">Doge Address</param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.DogeAPI.IClient.GetAddressReceivedTxAsync(System.String,System.Threading.CancellationToken)">
            <summary>Doge Address spended transactions</summary>
            <param name="address">Doge Address</param>
            <param name="cancellationToken"></param>
            <returns>Object containing collection of Utxos</returns>
            <exception cref="T:VEDriversLite.DogeAPI.ApiException">A server side error occurred.</exception>
        </member>
        <member name="T:VEDriversLite.DogeTransactionHelpers">
            <summary>
            Doge Transaction Helpers
            </summary>
        </member>
        <member name="F:VEDriversLite.DogeTransactionHelpers.FromSatToMainRatio">
            <summary>
            Conversion ration for Doge to convert from sat to 1 DOGE
            </summary>
        </member>
        <member name="F:VEDriversLite.DogeTransactionHelpers.Network">
            <summary>
            NBitcoin Instance of Mainet Network of Dogecoin
            </summary>
        </member>
        <member name="F:VEDriversLite.DogeTransactionHelpers.MinimumConfirmations">
            <summary>
            Minimum number of confirmation to send the transaction
            </summary>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.SignAndBroadcastTransaction(NBitcoin.Transaction,NBitcoin.BitcoinSecret,System.Collections.Generic.ICollection{VEDriversLite.DogeAPI.Utxo})">
            <summary>
            Function will sign transaction with provided key and broadcast with Neblio API
            </summary>
            <param name="transaction">NBitcoin Transaction object</param>
            <param name="key">NBitcoin Key - must contain Private Key</param>
            <param name="address">NBitcoin address - must match with the provided key</param>
            <param name="utxos">List of the input utxos</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.CalcFee(System.Int32,System.Int32,System.String,System.Boolean)">
            <summary>
            This function will calculate the fee based of the known lenght of the intputs and the outputs
            If there is the OP_RETURN output it is considered as the customMessage. Please fill it for token transactions.
            Token transaction also will add just for sure one output to calculation of the size for the case there will be some tokens back to original address
            </summary>
            <param name="numOfInputs">Number of input of the transaction "in" vector</param>
            <param name="numOfOutputs">Number of outpus of the transaction "out" vector</param>
            <param name="customMessageInOPReturn">Custom message - "OP_RETURN" output</param>
            <param name="isTokenTransaction">Token transaction will add another output for getting back the tokens</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.GetTransactionWithDogecoinInputs(System.Collections.Generic.ICollection{VEDriversLite.DogeAPI.Utxo},NBitcoin.BitcoinAddress)">
            <summary>
            This function will crate empty Transaction object based on Neblio network standard
            Then add the Neblio Inputs and sumarize their value
            </summary>
            <param name="dutxos">List of Dogecoin Utxos to use</param>
            <param name="address">Address of the owner</param>
            <returns>(NBitcoin Transaction object, sum of all inputs values in double)</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.GetDogeTransactionAsync(VEDriversLite.SendTxData,NBitcoin.BitcoinAddress,System.Collections.Generic.ICollection{VEDriversLite.DogeAPI.Utxo})">
            <summary>
            Function will send standard Neblio transaction - Async version
            </summary>
            <param name="data">Send data, please see SendTxData class for the details</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="utxos">Optional input neblio utxo</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.GetDogeTransactionWithMessageAsync(VEDriversLite.SendTxData,NBitcoin.BitcoinAddress,System.Collections.Generic.ICollection{VEDriversLite.DogeAPI.Utxo})">
            <summary>
            Function will send standard Neblio transaction with included message.
            </summary>
            <param name="data">Send data, please see SendTxData class for the details - this include field for custom message</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="utxos">Optional input neblio utxo</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.SendDogeTransactionWithMessageMultipleOutputAsync(System.Collections.Generic.Dictionary{System.String,System.Double},NBitcoin.BitcoinAddress,System.Collections.Generic.ICollection{VEDriversLite.DogeAPI.Utxo},System.String,System.String)">
            <summary>
            Function will send standard Neblio transaction with message and outputs which goes to different addresses
            </summary>
            <param name="receiverAmount">Dictionary of all receivers and amounts to send them</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="utxos">Optional input neblio utxo</param>
            <param name="password">Password for encrypted key if it is encrypted and locked</param>
            <param name="message">Custom message</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.ParseTotalSentValue(VEDriversLite.DogeAPI.GetTransactionInfoResponse)">
            <summary>
            Parse the total sent value from Doge Tx Info. It takes all outputs together.
            </summary>
            <param name="txinfo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.ParseDogeMessage(VEDriversLite.DogeAPI.GetTransactionInfoResponse)">
            <summary>
            Parse Message from Doge transaction (from OP_RETURN)
            </summary>
            <param name="txinfo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.ValidateDogeAddress(System.String)">
            <summary>
            Verify the Dogecoin address
            </summary>
            <param name="dogeAddress">Excpected Dogecoin address</param>
            <returns>true and Address if it is correct Dogecoin Address</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.IsPrivateKeyValid(System.String)">
            <summary>
            Verify the Dogecoin private key
            </summary>
            <param name="privatekey">Excpected Dogecoin private key</param>
            <returns>true and NBitcoin.BitcoinSecret if it is correct Dogecoin private key</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.GetAddressFromPrivateKey(System.String)">
            <summary>
            Get Address from Dogecoin private key
            </summary>
            <param name="privatekey">Excpected Dogecoin private key</param>
            <returns>true and Address if it is correct Dogecoin private key</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.GetClient">
            <summary>
            Returns private client for Neblio API. If it is null, it will create new instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.ChainSoBroadcastTxAsync(VEDriversLite.DogeAPI.ChainSoBroadcastTxRequest)">
            <summary>
            Broadcast of signed transaction. with chain.so
            </summary>
            <param name="data">tx hex</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.VENFTBroadcastTxAsync(VEDriversLite.DogeAPI.VENFTBroadcastTxRequest)">
            <summary>
            Broadcast of signed transaction. with VENFT API
            </summary>
            <param name="data">tx hex</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.AddressUtxosAsync(System.String)">
            <summary>
            Return address info object. this object contains list of Utxos.
            </summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.AddressSpendTxsAsync(System.String)">
            <summary>
            Return address spended transaction list. 
            </summary>
            <param name="addr"></param>
            <returns>This object contains list of spended Txs.</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.AddressReceivedTxsAsync(System.String)">
            <summary>
            Return address received transaction list. 
            </summary>
            <param name="addr"></param>
            <returns>This object contains list of spended Txs.</returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.TransactionInfoAsync(System.String,System.Boolean)">
            <summary>
            Return transaction object
            </summary>
            <param name="txid"></param>
            <param name="fromMemory"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.DogeTransactionHelpers.GetAddressSpendableUtxo(System.String,System.Double,System.Double)">
            <summary>
            Returns list of spendable utxos which together match some input required amount for some transaction
            </summary>
            <param name="addr">address which has utxos for spend - sender in tx</param>
            <param name="minAmount">minimum amount of one utxo</param>
            <param name="requiredAmount">amount what must be collected even by multiple utxos</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Dto.AccountExportDto">
            <summary>
            Dto for the export and import of the account or subaccount
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.AccountExportDto.Address">
            <summary>
            Address of the account
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.AccountExportDto.EKey">
            <summary>
            Encrypted key
            Usually the subaccount are encrypted with the master account key
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.AccountExportDto.ESKey">
            <summary>
            If the key is encrypted with use of the Symetric encryption load it here
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.AccountExportDto.Name">
            <summary>
            Name of the account or subaccount
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.AccountExportDto.Password">
            <summary>
            Password for decryption of the EKey
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.AccountExportDto.IsDogeAccount">
            <summary>
            Set this flag if it is doge account
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.AccountExportDto.ConnectToMainShop">
            <summary>
            Connect this account to the Main shop account
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.AccountExportDto.IsReceivingAccount">
            <summary>
            Set this if this is receiving account of the use of the shop functions
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.AccountExportDto.IsDepositAccount">
            <summary>
            Set this if this is deposit account of the use of the shop functions
            </summary>
        </member>
        <member name="T:VEDriversLite.Dto.BackupDataDto">
            <summary>
            VENFT Backup Data Dto
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.Bookmarks">
            <summary>
            Serialized Bookmarks list
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.BrowserTabs">
            <summary>
            Serialized browser tabs list
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.MessageTabs">
            <summary>
            Serialized message tabs list
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.SubAccounts">
            <summary>
            Serialized SubAccounts list
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.Address">
            <summary>
            Main NeblioAddress
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.Key">
            <summary>
            Main NeblioAddress Key
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.DogeAddress">
            <summary>
            Main Dogecoin Address
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.DogeKey">
            <summary>
            Main Dogecoin Address Key
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.WoCAPIUrl">
            <summary>
            Connection Url for WooCommerce eshop
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.WoCAPIKey">
            <summary>
            Connection API Key for the WooCommerce eshop
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.WoCAPISecret">
            <summary>
            Connection API Secret for the WooCommerce eshop
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.BackupDataDto.WoCAPIJWT">
            <summary>
            Connection API JWT Token for the WordPress
            </summary>
        </member>
        <member name="T:VEDriversLite.Dto.DepositAddress">
            <summary>
            Deposit Address - it is address where shop will resend the payment for store/deposit after the NFT was send
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositAddress.Name">
            <summary>
            Name of the Deposit address
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositAddress.Address">
            <summary>
            Deposit Address
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositAddress.TakeAddressFromNFT">
            <summary>
            If you dont have it take if from the NFT data
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositAddress.Currency">
            <summary>
            Name of the currency
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositAddress.Percentage">
            <summary>
            Percentage of the amount what should be send to the deposit address from whole received amount
            </summary>
        </member>
        <member name="T:VEDriversLite.Dto.DepositScheme">
            <summary>
            Deposit scheme can split the amount to multiple accounts.
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositScheme.Name">
            <summary>
            Name of the deposit scheme
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositScheme.Currency">
            <summary>
            Name of the currency
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositScheme.MainDepositAddress">
            <summary>
            Main deposit address (if there is no others the payment goes there
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositScheme.IsActive">
            <summary>
            Is the deposit scheme active
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.DepositScheme.DepositAddresses">
            <summary>
            Dictionary of the addresses for the deposit of the received payment for some NFT
            If there are more then one the amount is splited based on the percentage in DepositAddress class
            </summary>
        </member>
        <member name="T:VEDriversLite.Dto.SplitNeblioDto">
            <summary>
            Dto for split Neblio transaction request
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.SplitNeblioDto.receivers">
            <summary>
            Addresses of the receivers
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.SplitNeblioDto.lots">
            <summary>
            Number of the lots
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.SplitNeblioDto.amount">
            <summary>
            Amount of the Neblio in one lot
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.SplitNeblioDto.TotalAmount">
            <summary>
            Total amount of all lots together
            </summary>
        </member>
        <member name="T:VEDriversLite.Dto.SplitNeblioTokensDto">
            <summary>
            Split Neblio tokens Dto.
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.SplitNeblioTokensDto.receivers">
            <summary>
            Addresses of the receivers
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.SplitNeblioTokensDto.lots">
            <summary>
            Number of the lots
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.SplitNeblioTokensDto.amount">
            <summary>
            Amount of the tokens
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.SplitNeblioTokensDto.tokenId">
            <summary>
            Token Id
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.SplitNeblioTokensDto.TotalAmount">
            <summary>
            Total amount of all lots together
            </summary>
        </member>
        <member name="T:VEDriversLite.Dto.TokenOwnerDto">
            <summary>
            Dto for info about owner of some kind of the tokens
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.TokenOwnerDto.Address">
            <summary>
            Address of the Owner
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.TokenOwnerDto.ShortenAddress">
            <summary>
            Shorten Address of the Owner
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.TokenOwnerDto.AmountOfTokens">
            <summary>
            Amount of the tokens on the Owner Address
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.TokenOwnerDto.AmountOfNFTs">
            <summary>
            Amount of the NFTs on the Owner Address
            </summary>
        </member>
        <member name="T:VEDriversLite.Dto.TokenSupplyDto">
            <summary>
            Dto for info about actual Token supply on address
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.TokenSupplyDto.TokenSymbol">
            <summary>
            Symbol of token - up to 5 unique letters
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.TokenSupplyDto.TokenId">
            <summary>
            Token Id hash
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.TokenSupplyDto.Amount">
            <summary>
            Amount of tokens available
            </summary>
        </member>
        <member name="P:VEDriversLite.Dto.TokenSupplyDto.ImageUrl">
            <summary>
            Token icon image url
            </summary>
        </member>
        <member name="T:VEDriversLite.KeyDto">
            <summary>
            Key export import Dto
            </summary>
        </member>
        <member name="P:VEDriversLite.KeyDto.Address">
            <summary>
            Address
            </summary>
        </member>
        <member name="P:VEDriversLite.KeyDto.Key">
            <summary>
            Private key - usually exported in encrypted form
            </summary>
        </member>
        <member name="T:VEDriversLite.MintNFTData">
            <summary>
            Mint NFT Data Dto for NeblioTransactionHelpers MintNFT functions
            </summary>
        </member>
        <member name="M:VEDriversLite.MintNFTData.#ctor">
            <summary>
            Init the metdata dictionary in constructor
            </summary>
        </member>
        <member name="P:VEDriversLite.MintNFTData.SenderAddress">
            <summary>
            Address from where token will be send
            </summary>
        </member>
        <member name="P:VEDriversLite.MintNFTData.ReceiverAddress">
            <summary>
            Address from where to send new NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.MintNFTData.MultipleReceivers">
            <summary>
            Fill when you have multiple receivers
            Works now just for multimint of NFTs example in VEBlazor.Demo.TicketsAndEvents for minting tickets
            </summary>
        </member>
        <member name="P:VEDriversLite.MintNFTData.Password">
            <summary>
            If the account is locked you can provide password directly in the send token api command
            if the account is unlocked or the QT wallet is connected fill empty string
            </summary>
        </member>
        <member name="P:VEDriversLite.MintNFTData.Id">
            <summary>
            Id of token
            </summary>
        </member>
        <member name="P:VEDriversLite.MintNFTData.Metadata">
            <summary>
            Metadata dictionary, key-value pairs
            </summary>
        </member>
        <member name="P:VEDriversLite.MintNFTData.sendUtxo">
            <summary>
            Initial Utxo for sending transaction from
            </summary>
        </member>
        <member name="P:VEDriversLite.MintNFTData.UseRPCPrimarily">
            <summary>
            If you use RPC and NBitcoin you can preffer using RPC with set this to true
            </summary>
        </member>
        <member name="T:VEDriversLite.SendTokenTxData">
            <summary>
            Data carrier for sending token
            </summary>
        </member>
        <member name="M:VEDriversLite.SendTokenTxData.#ctor">
            <summary>
            Init the metdata dictionary in constructor
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.SenderAddress">
            <summary>
            Address from where token will be send
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.Password">
            <summary>
            If the account is locked you can provide password directly in the send token api command
            if the account is unlocked or the QT wallet is connected fill empty string
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.ReceiverAddress">
            <summary>
            Address where token will be send
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.Symbol">
            <summary>
            Symbol of token
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.Id">
            <summary>
            Id of token
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.Amount">
            <summary>
            Amount of the tokens
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.Metadata">
            <summary>
            Metadata dictionary, key-value pairs
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.sendUtxo">
            <summary>
            Initial Utxo for sending transaction from if you want to specify them
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.NeblUtxo">
            <summary>
            If you wish to add specific neblio utxo as source for the fee
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.SendEvenNeblUtxoNotFound">
            <summary>
            If this is set and you will provide NeblUtxo, but it is not found in the list of spendable nebl utxos
            it will find another spendable utxo
            If this is not set and utxo is not found it will throw exception
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTokenTxData.UseRPCPrimarily">
            <summary>
            If you use RPC and NBitcoin you can preffer using RPC with set this to true
            </summary>
        </member>
        <member name="T:VEDriversLite.SendTxData">
            <summary>
            Data carrier for sending classic cryptocurrency transaction
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTxData.SenderAddress">
            <summary>
            Address from where token will be send
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTxData.Password">
            <summary>
            If the account is locked you can provide password directly in the send token api command
            if the account is unlocked or the QT wallet is connected fill empty string
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTxData.ReceiverAddress">
            <summary>
            Address where token will be send
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTxData.Symbol">
            <summary>
            Symbol of token
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTxData.Id">
            <summary>
            Id of token
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTxData.Amount">
            <summary>
            Amount of the currency
            </summary>
        </member>
        <member name="P:VEDriversLite.SendTxData.CustomMessage">
            <summary>
            Custom message if it is supported by currency, not implemented yet
            </summary>
        </member>
        <member name="T:VEDriversLite.Events.CommonEvent">
            <summary>
            Basic implementation of the Event interface.
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.CommonEvent.Type">
            <summary>
            Event type
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.CommonEvent.Address">
            <summary>
            Address which created this event info
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.CommonEvent.Title">
            <summary>
            Title of the event info
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.CommonEvent.Message">
            <summary>
            Message content
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.CommonEvent.TxId">
            <summary>
            Related transaction
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.CommonEvent.Data">
            <summary>
            Related data
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.CommonEvent.Progress">
            <summary>
            Progress of the task which created the event
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.CommonEvent.TimeStamp">
            <summary>
            Time stamp of the situation
            </summary>
        </member>
        <member name="M:VEDriversLite.Events.CommonEvent.Fill(VEDriversLite.Events.IEventInfo)">
            <summary>
            Fill the dto
            </summary>
            <param name="ev"></param>
        </member>
        <member name="M:VEDriversLite.Events.CommonEvent.ParseData``1">
            <summary>
            Parse the data of the event
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Events.ErrorEvent">
            <summary>
            Definition of the ErrorEvent
            </summary>
        </member>
        <member name="M:VEDriversLite.Events.ErrorEvent.#ctor(System.String,System.String)">
            <summary>
            construct the event
            </summary>
            <param name="title"></param>
            <param name="message"></param>
        </member>
        <member name="T:VEDriversLite.Events.EventFactory">
            <summary>
            Get Event based on the type
            </summary>
        </member>
        <member name="M:VEDriversLite.Events.EventFactory.GetEvent(VEDriversLite.Events.EventType,System.String,System.String,System.String,System.String,System.Double)">
            <summary>
            Get Event based on the type
            </summary>
            <param name="type"></param>
            <param name="title"></param>
            <param name="message"></param>
            <param name="address"></param>
            <param name="txid"></param>
            <param name="progress"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Events.EventFactory.Clone(VEDriversLite.Events.IEventInfo,System.Boolean,VEDriversLite.Events.EventType)">
            <summary>
            Clone the event object
            </summary>
            <param name="inev"></param>
            <param name="asType"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Events.EventInfoProvider">
            <summary>
            Store and get infos
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.EventInfoProvider.EventInfoStore">
            <summary>
            Storage of the Events
            </summary>
        </member>
        <member name="M:VEDriversLite.Events.EventInfoProvider.AddNewEventInfo(VEDriversLite.Events.IEventInfo)">
            <summary>
            Add event to the buffer
            </summary>
            <param name="evinfo"></param>
        </member>
        <member name="M:VEDriversLite.Events.EventInfoProvider.DequeueEventInfo(VEDriversLite.Events.IEventInfo)">
            <summary>
            Get the event from the buffer
            </summary>
            <param name="evinfo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Events.EventInfoProvider.StoreEventInfo(VEDriversLite.Events.IEventInfo)">
            <summary>
            Save event info to the buffer
            </summary>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Events.EventInfoProvider.DeleteEventInfo(System.String)">
            <summary>
            Delete stored info in the buffer
            </summary>
            <param name="guid"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Events.EventType">
            <summary>
            Type of the event
            </summary>
        </member>
        <member name="F:VEDriversLite.Events.EventType.Basic">
            <summary>
            Basic
            </summary>
        </member>
        <member name="F:VEDriversLite.Events.EventType.Info">
            <summary>
            Info
            </summary>
        </member>
        <member name="F:VEDriversLite.Events.EventType.Warning">
            <summary>
            Warning
            </summary>
        </member>
        <member name="F:VEDriversLite.Events.EventType.Error">
            <summary>
            Error
            </summary>
        </member>
        <member name="F:VEDriversLite.Events.EventType.TxSending">
            <summary>
            Sending transaction
            </summary>
        </member>
        <member name="F:VEDriversLite.Events.EventType.TxReceived">
            <summary>
            Receiving transaction
            </summary>
        </member>
        <member name="F:VEDriversLite.Events.EventType.NFTReceived">
            <summary>
            NFT Received        
            </summary>
        </member>
        <member name="T:VEDriversLite.Events.IEventInfo">
            <summary>
            Main interface for the Event infos
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.IEventInfo.Type">
            <summary>
            Event type
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.IEventInfo.Address">
            <summary>
            Address which created this event info
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.IEventInfo.Title">
            <summary>
            Title of the event info
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.IEventInfo.Message">
            <summary>
            Message content
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.IEventInfo.TxId">
            <summary>
            Related transaction
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.IEventInfo.Data">
            <summary>
            Related data
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.IEventInfo.Progress">
            <summary>
            Progress of the task which created the event
            </summary>
        </member>
        <member name="P:VEDriversLite.Events.IEventInfo.TimeStamp">
            <summary>
            Time stamp of the situation
            </summary>
        </member>
        <member name="M:VEDriversLite.Events.IEventInfo.Fill(VEDriversLite.Events.IEventInfo)">
            <summary>
            Fill the dto
            </summary>
            <param name="ev"></param>
        </member>
        <member name="M:VEDriversLite.Events.IEventInfo.ParseData``1">
            <summary>
            Parse the data of the event
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Events.InfoEvent">
            <summary>
            Info event object
            </summary>
        </member>
        <member name="M:VEDriversLite.Events.InfoEvent.#ctor(System.String,System.String)">
            <summary>
            Create info event object
            </summary>
            <param name="title"></param>
            <param name="message"></param>
        </member>
        <member name="T:VEDriversLite.Messaging.MessageTab">
            <summary>
            Message tab loads the messages between main address and the partner address
            </summary>
        </member>
        <member name="M:VEDriversLite.Messaging.MessageTab.#ctor(System.String)">
            <summary>
            Main constructor. Input the address of the partner
            </summary>
            <param name="address"></param>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.Selected">
            <summary>
            Message tab is selected
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.Address">
            <summary>
            Address of the partner - loaded address
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.AccountAddress">
            <summary>
            Address of the main account
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.AccountSecret">
            <summary>
            Main Account Secret - it is used for decryption of the messages
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.ShortAddress">
            <summary>
            Shorten address of the partner
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.IsInBookmark">
            <summary>
            This flag is set when address of the partner is stored in the bookmark of the main account
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.NFTs">
            <summary>
            List of the NFTs of partner address
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.NFTMessages">
            <summary>
            List of the NFTs related to the conversation between main account and partner address
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.BookmarkFromAccount">
            <summary>
            Loaded bookaark form the main account if the bookmark exists
            Otherwise it is empty (not null)
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.Profile">
            <summary>
            Profile of the partner account - it is NFT profile
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.PublicKey">
            <summary>
            Public key of the partner if it was already found
            </summary>
        </member>
        <member name="P:VEDriversLite.Messaging.MessageTab.PublicKeyFound">
            <summary>
            This is set when the public key has been already found and loaded
            </summary>
        </member>
        <member name="M:VEDriversLite.Messaging.MessageTab.Reload(System.Collections.Generic.List{VEDriversLite.NFT.INFT})">
            <summary>
            Reload the NFTs 
            </summary>
            <param name="innfts"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Messaging.MessageTab.RefreshMessages(System.Collections.Generic.List{VEDriversLite.NFT.INFT})">
            <summary>
            Refresh the messages list
            </summary>
            <param name="innfts"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Messaging.MessageTab.AddAccoundMessages(System.Collections.Generic.List{VEDriversLite.NFT.INFT})">
            <summary>
            Add messages from the main account to the list
            This will combine list of received and sent messages to one list
            </summary>
            <param name="innfts"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Messaging.MessageTab.LoadBookmark(VEDriversLite.Bookmarks.Bookmark)">
            <summary>
            Load the bookmark object
            </summary>
            <param name="bkm"></param>
        </member>
        <member name="M:VEDriversLite.Messaging.MessageTab.ClearBookmark">
            <summary>
            Clear the bookmark object
            </summary>
        </member>
        <member name="T:VEDriversLite.NeblioAccount">
            <summary>
            Main Neblio Account Class
            </summary>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.#ctor">
            <summary>
            Main constructor
            </summary>
        </member>
        <member name="P:VEDriversLite.NeblioAccount.LastCheckedDogePaymentUtxo">
            <summary>
            Check of the DogeAccount for NFT payments - obsolete. will be redesign in the issue 33
            </summary>
        </member>
        <member name="P:VEDriversLite.NeblioAccount.RunningAsVENFTBlazorApp">
            <summary>
            This will block the automatic start of the NFT IoT Devices. 
            It is recommended to use NFT IoT devices in the services instead of the web assembly
            </summary>
        </member>
        <member name="P:VEDriversLite.NeblioAccount.Tabs">
            <summary>
            List of all active tabs for browsing or interacting with the address. All has possibility to load own list of NFTs.
            </summary>
        </member>
        <member name="P:VEDriversLite.NeblioAccount.MessageTabs">
            <summary>
            Tabs with partners for messaging. It loads their NFT Messages related to you and mix them with yours related to the address in MessageTab
            </summary>
        </member>
        <member name="P:VEDriversLite.NeblioAccount.SubAccounts">
            <summary>
            Neblio Sub Accounts. Each can work with own set of NFTs. It is real blockchain address with own Private Key
            </summary>
        </member>
        <member name="P:VEDriversLite.NeblioAccount.Bookmarks">
            <summary>
            List of all saved bookmarks. This is just realtime carrier. It need some serialization/deserialization.
            </summary>
        </member>
        <member name="E:VEDriversLite.NeblioAccount.Refreshed">
            <summary>
            This event is called whenever info about the address is reloaded. It is periodic event.
            </summary>
        </member>
        <member name="E:VEDriversLite.NeblioAccount.NewMintingProcessInfo">
            <summary>
            This event is called whenever some progress during multimint happens
            </summary>
        </member>
        <member name="E:VEDriversLite.NeblioAccount.AddressesAirdroped">
            <summary>
            This event is fired whenever new lot of addresses was airdroped
            </summary>
        </member>
        <member name="E:VEDriversLite.NeblioAccount.SubAccountNFTsChanged">
            <summary>
            This event is called whenever the list of NFTs on SubAccount is changed
            </summary>
        </member>
        <member name="E:VEDriversLite.NeblioAccount.TabNFTsChanged">
            <summary>
            This event is called whenever the list of NFTs is changed
            </summary>
        </member>
        <member name="E:VEDriversLite.NeblioAccount.FirsLoadingStatus">
            <summary>
            This event is called during first loading of the account to keep updated the user
            </summary>
        </member>
        <member name="E:VEDriversLite.NeblioAccount.AccountFirsLoadFinished">
            <summary>
            This event is called when first loading of the account is finished
            </summary>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.InitHandlers">
            <summary>
            This function will register event info from NeblioTransactionHelpers class.
            </summary>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.DeInitHandlers">
            <summary>
            This function will unregister event info from NeblioTransactionHelpers class.
            </summary>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.NeblioTransactionHelpers_NewEventInfo(System.Object,VEDriversLite.Events.IEventInfo)">
            <summary>
            Handler for event info messages. Now it just store events in common store.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.StartRefreshingData(System.Int32)">
            <summary>
            This function will load the actual data and then run the task which periodically refresh this data.
            It doesnt have cancellation now!
            </summary>
            <param name="interval">Default interval is 3000 = 3 seconds</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.CreateNewAccount(System.String,System.Boolean,System.String)">
            <summary>
            This function will create new account - Neblio address and its Private key.
            </summary>
            <param name="password">Input password, which will encrypt the Private key</param>
            <param name="saveToFile">if you want to save it to the file (dont work in the WASM) set this. It will save to root exe path as key.txt</param>
            <param name="filename">default filename is key.txt you can change it, but remember to load same name when loading the account.</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadAccount(System.String,System.String,System.Boolean)">
            <summary>
            Load account from filename (default "key.txt") file placed in the root exe directory. Doesnt work in WABS
            </summary>
            <param name="password">Passwotd to decrypt the loaded private key</param>
            <param name="filename">filename with stored key.</param>
            <param name="withoutNFTs">choose if you want to skip NFTs during loading the account. 
            Great when you want just do simple payment. 
            You can then swithc off WithoutNFTs property and account will load them in next refresh.</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadAccountWithDummyKey(System.String,System.String,System.Boolean)">
            <summary>
            Load account just for observation
            You cannot sign tx when you load address this way
            </summary>
            <param name="password">Passwotd to decrypt the loaded private key</param>
            <param name="address">Account Address</param>
            <param name="withoutNFTs">choose if you want to skip NFTs during loading the account. 
            Great when you want just do simple payment. 
            You can then swithc off WithoutNFTs property and account will load them in next refresh.</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadAccountFromVENFTBackup(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Load account from filename backup from VENFT App (default "backup.json") file placed in the root exe directory. Doesnt work in WABS
            </summary>
            <param name="password">Passwotd to decrypt the loaded private key</param>
            <param name="fromString">BackupDataDto serialized object with key and address</param>
            <param name="filename">load from BackupDataDto from file. backup.json as default.</param>
            <param name="withoutNFTs">choose if you want to skip NFTs during loading the account. 
            Great when you want just do simple payment. 
            You can then swithc off WithoutNFTs property and account will load them in next refresh.</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadAccount(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Load account from password, input encrypted private key and address.
            It expect the private key is encrypted by the password.
            It uses AES encryption
            </summary>
            <param name="password">Passwotd to decrypt the loaded private key</param>
            <param name="encryptedKey">Private key encrypted with AES (you must provide pass in this case) or not encrypted (you do not need password)</param>
            <param name="address">Neblio Address related to the private key (if empty it will be calculated from the private key).</param>
            <param name="withoutNFTs">choose if you want to skip NFTs during loading the account. 
            Great when you want just do simple payment. 
            You can then swithc off WithoutNFTs property and account will load them in next refresh.</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.CacheNFTs">
            <summary>
            Serialize the NFTCache dictionary
            </summary>
            <returns>Serialized VEDLDataContext.NFTCache</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadCacheNFTsFromString(System.String)">
            <summary>
            Load the data from the stirng to the Dictionary of the NFTs cache
            The input string must be serialized NFTCache dictionary from VEDriversLite with use of the function CacheNFTs from this class
            </summary>
            <param name="cacheString">Input serialized NFTCache dictionary as string</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadCacheNFTsFromString(System.Collections.Generic.IDictionary{System.String,VEDriversLite.NFT.Dto.NFTCacheDto})">
            <summary>
            Load the NFTCache data from the input dictionary to the Dictionary of the NFTs cache
            The input must be dictionary which contains NFTCacheDto as value with cache data
            </summary>
            <param name="nfts">Input NFTCache dictionary</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadBookmarks(System.String)">
            <summary>
            Load bookmarks from previous serialized list of bookmarks. 
            </summary>
            <param name="bookmarks"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.AddBookmark(System.String,System.String,System.String)">
            <summary>
            Add new bookmark to bookmark list and return serialized list for save
            </summary>
            <param name="name">Name of the bookmark. It is important for most functions which work with the bookmarks</param>
            <param name="address">Neblio Address</param>
            <param name="note">optional note</param>
            <returns>Serialized list in string for save</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.RemoveBookmark(System.String)">
            <summary>
            Remove bookmark by the neblio address. It must be found in the bookmark list
            </summary>
            <param name="address"></param>
            <returns>Serialized list in string for save</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SerializeBookmarks">
            <summary>
            Get serialized bookmarks list as string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.IsInTheBookmarks(System.String)">
            <summary>
            Check if the address is already in the bookmarks and return this bookmark
            </summary>
            <param name="address">Address or Name which should be in the bookmarks</param>
            <returns>true and bookmark class if exists</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadTabs(System.String)">
            <summary>
            Load tabs from previous serialized string.
            </summary>
            <param name="tabs">List of ActiveTabs as json string</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.AddTab(System.String,System.Int32)">
            <summary>
            Add new tab based on some Neblio address
            </summary>
            <param name="address"></param>
            <returns>true and string with serialized tabs list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.RemoveTab(System.String)">
            <summary>
            Remove tab by Neblio address if exists in the tabs
            </summary>
            <param name="address">Neblio Address which tab should be removed</param>
            <returns>true and string with serialized tabs list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SelectTab(System.String)">
            <summary>
            Select active tab based on Address. It will deselect all other tabs
            This will start the refreshing for the selected tab if is not running yet and stop the others tabs refreshing.
            </summary>
            <param name="address">Address of tab to select</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SerializeTabs">
            <summary>
            Return serialized list of ActiveTabs as Json stirng
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadMessageTabs(System.String)">
            <summary>
            Load tabs from previous serialized string.
            </summary>
            <param name="tabs">List of MessageTabs as json string</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.AddMessageTab(System.String)">
            <summary>
            Add new message tab based on some Neblio address
            </summary>
            <param name="address"></param>
            <returns>true and string with serialized tabs list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.RemoveMessageTab(System.String)">
            <summary>
            Remove tab by Neblio address if exists in the tabs
            </summary>
            <param name="address">Neblio Address which tab should be removed</param>
            <returns>true and string with serialized tabs list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SelectMessageTab(System.String)">
            <summary>
            Select Message tab. It will Reload the tab NFTs if the count of the NFTs is 0.
            </summary>
            <param name="address">Address of Message Tab to select</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SerializeMessageTabs">
            <summary>
            Return serialized list of MessageTabs as Json stirng
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.LoadSubAccounts(System.String)">
            <summary>
            Load subaccounts from previous serialized string.
            </summary>
            <param name="subaccounts">List of SubAccountsAddressExports as json string</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.AddSubAccount(System.String,System.Boolean,System.Double,System.Boolean,System.Double,System.String)">
            <summary>
            Add new Sub Account
            </summary>
            <param name="name">Name of new SubAccount</param>
            <param name="sendNeblioToAccount">Set This true if you want to load some Neblio to this address after it is created.</param>
            <param name="neblioAmountToSend">Amount of neblio for initial load of the address, 0.05 is default = 250 tx</param>
            <param name="sendTokenToAccount">Initial amount of tokens to send to the new SubAccount</param>
            <param name="tokenAmountToSend">Initial amount of Neblio to send to the new SubAccount</param>
            <param name="tokenId">Token Id which should be send to the new SubAccount</param>
            <returns>true and string with serialized tabs list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.RemoveSubAccount(System.String)">
            <summary>
            Remove Sub Account by Neblio address if exists in the dictionary
            Please remember that this function will destroy account. Please do backup first.
            </summary>
            <param name="address">Neblio Address which tab should be removed</param>
            <returns>true and string with serialized subaccount account export dto list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.GetSubAccountAddressByName(System.String)">
            <summary>
            Get sub account address by name
            </summary>
            <param name="name">Neblio Sub Account Name</param>
            <returns>true and string with serialized subaccount account export dto list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.GetSubAccountNameByAddress(System.String)">
            <summary>
            Get sub account name by address
            </summary>
            <param name="address">Neblio Sub Account Name</param>
            <returns>true and string with serialized subaccount account export dto list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.GetSubAccounTotaltSpendableActualBalance(System.String)">
            <summary>
            Get Total spendable balance
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.GetSubAccounUnconfirmedActualBalance(System.String)">
            <summary>
            Get Total unconfirmed balance
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.ChangeSubAccountName(System.String,System.String)">
            <summary>
            Change Sub Account Name if exists in the dictionary
            Automatically is changed name in bookmarks too. Thats why function will return both serialized lists
            </summary>
            <param name="address">Neblio Address which tab should be renamed</param>
            <param name="newName">New Name</param>
            <returns>true and string with serialized subaccount account export dto list as json string nad bookmarks list</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.GetSubAccountKeys">
            <summary>
            Get Sub Account Keys for export
            </summary>
            <returns>true and dictionary with addresses and private keys</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SendNFTFromSubAccount(System.String,System.String,VEDriversLite.NFT.INFT,System.Boolean,System.Boolean,System.Double,System.Boolean,System.Double)">
            <summary>
            Send NFT From SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="receiver">Receiver of the NFT</param>
            <param name="NFT">NFT on the SubAccount which should be send</param>
            <param name="sendToMainAccount">If this is set, function will rewrite receiver to main Account Address</param>
            <param name="withPrice"></param>
            <param name="price"></param>
            <param name="withDogePrice"></param>
            <param name="dogeprice"></param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.ReturnNFTPaymentFromSubAccount(System.String,System.String,VEDriversLite.NFT.INFT)">
            <summary>
            Return NFT Payment From SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="receiver">Receiver of the NFT</param>
            <param name="NFT">NFT Payment on the SubAccount which should be return</param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.ChangeNFTOnSubAccount(System.String,VEDriversLite.NFT.INFT)">
            <summary>
            Change NFT on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="NFT">NFT on the SubAccount which should be changed</param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.MintNFTOnSubAccount(System.String,VEDriversLite.NFT.INFT,System.String)">
            <summary>
            Mint NFT on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="NFT">NFT on the SubAccount which should be minted</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.MultimintNFTLargeOnSubAccount(System.String,VEDriversLite.NFT.INFT,System.Int32,System.String)">
            <summary>
            Multi Mint of large amount of NFTs on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="NFT">NFT on the SubAccount which should be minted</param>
            <param name="receiver">Receiver of the NFT</param>
            <param name="coppies"></param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SendNeblioOnSubAccount(System.String,System.String,System.Double,System.String)">
            <summary>
            Send Neblio Coin on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="receiver">receiver Neblio address</param>
            <param name="amount">amount of neblio</param>
            <param name="message">optional message</param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SendNeblioTokensOnSubAccount(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.Int32)">
            <summary>
            Send Neblio Tokens on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="tokenId">Neblio NTP1 token Id</param>
            <param name="meta">Metadata for transaction</param>
            <param name="receiver">receiver Neblio address</param>
            <param name="amount">amount of neblio</param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SplitNeblioOnSubAccount(System.String,System.Collections.Generic.List{System.String},System.Int32,System.Double)">
            <summary>
            Split Neblio Coin on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="receivers"></param>
            <param name="lots"></param>
            <param name="amount"></param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SplitNeblioTokensOnSubAccount(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.List{System.String},System.Int32,System.Int32)">
            <summary>
            Split Neblio Tokens on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="tokenId">Id of token to split</param>
            <param name="metadata">metadata</param>
            <param name="receivers">list of the receivers of the transaction.</param>
            <param name="lots">Number of lots on the Output of tx.</param>
            <param name="amount">Amount of the tokens in one lot.</param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.GetNFTVerifyQRCodeFromSubAccount(System.String,System.String)">
            <summary>
            Get QR verification code of NFT on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="txid">NFT utxo on the SubAccount</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.UseTicketNFTOnSubAccount(System.String,VEDriversLite.NFT.INFT)">
            <summary>
            Use Ticket NFT on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="NFT">NFT on the SubAccount which should be changed</param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SendCoruzantNFTOnSubAccount(System.String,VEDriversLite.NFT.INFT,System.String,System.Boolean,System.String)">
            <summary>
            Change Coruzant NFT on SubAccount or send it to another address
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="NFT">NFT on the SubAccount which should be changed</param>
            <param name="comment"></param>
            <param name="commentWrite"></param>
            <param name="receiver"></param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.DestroyNFTOnSubAccount(System.String,System.Collections.Generic.ICollection{VEDriversLite.NFT.INFT},System.Boolean)">
            <summary>
            Destroy NFTs on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <param name="NFTs">NFTs on the SubAccount which should be send</param>
            /// <param name="sendToMainAccount">If this is set, function will rewrite receiver to main Account Address</param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.GetNFTsOnSubAccount(System.String)">
            <summary>
            Get NFTs on SubAccount
            </summary>
            <param name="address">Neblio Address of SubAccount</param>
            <returns>true and string with new TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.AllowSubAccountAutorefreshing(System.String)">
            <summary>
            Allow autorefresh for specific SubAccount
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.StopSubAccountAutorefreshing(System.String)">
            <summary>
            Stop autorefresh for specific SubAccount
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.SerializeSubAccounts">
            <summary>
            Returns serialized subaccount account export dto list as json string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.ConnectDogeAccount(System.String)">
            <summary>
            connect Doge Account related to this account
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.DisconnectDogeAccount">
            <summary>
            Remove the connection of some Doge Account
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioAccount.OrderSourceTokens(System.Double)">
            <summary>
            This function will send request for 100 VENFT tokens. It can be process by sending 1 NEBL to specific project address.
            </summary>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Neblio.NeblioAccountBase">
            <summary>
            Basic function class for Neblio Account 
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.Address">
            <summary>
            Neblio Address hash
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.Secret">
            <summary>
            Loaded Secret, NBitcoin Class which carry Public Key and Private Key
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.NumberOfTransaction">
            <summary>
            Number of the transactions on the address. not used now
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.NumberOfLoadedTransaction">
            <summary>
            Number of already loaded transaction on the address. not used now
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.EnoughBalanceToBuySourceTokens">
            <summary>
            If the address has enought Neblio to buy source VENFT tokens (costs 1 NEBL) this is set as true.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.TotalBalance">
            <summary>
            Total actual balance based on Utxos. This means sum of spendable and unconfirmed balances.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.TotalSpendableBalance">
            <summary>
            Total spendable balance based on Utxos.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.TotalUnconfirmedBalance">
            <summary>
            Total balance which is now unconfirmed based on Utxos.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.SourceTokensBalance">
            <summary>
            Total balance of VENFT tokens which can be used for minting purposes.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.CoruzantSourceTokensBalance">
            <summary>
            Total balance of Coruzant tokens which can be used for minting purposes.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.AddressNFTCount">
            <summary>
            Total number of NFT on the address. It counts also Profile NFT, etc.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.IsRefreshingRunning">
            <summary>
            When main refreshing loop is running this is set
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.WithoutNFTs">
            <summary>
            If you want to run account without NFTs set this up. 
            Whenever during run you can clear this flag and NFTs will start loading
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.ConnectedDogeAccountAddress">
            <summary>
            If there is some Doge address in same project which should be searched for the payments triggers fill it here
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.NFTs">
            <summary>
            List of actual address NFTs. Based on Utxos list
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.CoruzantNFTs">
            <summary>
            List of actual address Coruzant NFTs. Based on Utxos list
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.HardwarioNFTs">
            <summary>
            List of actual address HARDWARIO NFTs. Based on Utxos list
            </summary>
        </member>
        <member name="F:VEDriversLite.Neblio.NeblioAccountBase.ReceivedPayments">
            <summary>
            Received payments (means Payment NFT) of this address.
            </summary>
        </member>
        <member name="F:VEDriversLite.Neblio.NeblioAccountBase.ReceivedReceipts">
            <summary>
            Received receipts (means Receipt NFT) of this address.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.Profile">
            <summary>
            If address has some profile NFT, it is founded in Utxo list and in this object.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.TokensSupplies">
            <summary>
            Actual all token supplies. Consider also other tokens than VENFT.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.Utxos">
            <summary>
            Actual list of all Utxos on this address.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.AddressInfo">
            <summary>
            Actual loaded address info. It has inside list of all transactions.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.AddressInfoUtxos">
            <summary>
            Actual loaded address info with list of Utxos. When utxos are loaded first, this is just fill with it to prevent not necessary API request.
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.UsedUtxos">
            <summary>
            When some utxo is used, it is placed to this list to prevent second use. Key is Utxo and Value is TxId where it was used
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioAccountBase.Refreshed">
            <summary>
            This event is fired whenever info about the address is reloaded. It is periodic event.
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioAccountBase.NewEventInfo">
            <summary>
            This event is fired whenever some important thing happen. You can obtain success, error and info messages.
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioAccountBase.NFTsChanged">
            <summary>
            This event is fired whenever the list of NFTs is changed
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioAccountBase.NewMintingProcessInfo">
            <summary>
            This event is fired whenever some progress during multimint happens
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioAccountBase.AddressesAirdroped">
            <summary>
            This event is fired whenever new lot of addresses was airdroped
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioAccountBase.ProfileUpdated">
            <summary>
            This event is fired whenever profile nft is updated or found
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioAccountBase.NFTAddedToPayments">
            <summary>
            This event is fired whenever some NFT is in received payment too and it should be blocked for any further action.
            It provides Utxo and UtxoIndex as touple.
            Event is fired also for the SubAccounts when it is registred from Main Account
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioAccountBase.FirsLoadingStatus">
            <summary>
            This event is fired during first loading of the account to keep updated the user
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioAccountBase.AccountKey">
            <summary>
            Carrier for encrypted private key from storage and its password.
            </summary>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.IsLocked">
            <summary>
            This function will check if the account is locked or unlocked.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.FireInfoEvent(System.Object,VEDriversLite.Events.IEventInfo)">
            <summary>
            Redirect Info Event from lower layer
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.InvokeSendPaymentSuccessEvent(System.String,System.String)">
            <summary>
            Invoke Success message info event
            </summary>
            <param name="txid">new tx id hash</param>
            <param name="title">Title of the event message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.InvokeAccountLockedEvent(System.String)">
            <summary>
            Invoke Error message because account is locked
            </summary>
            <param name="title">Title of the event message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.InvokeErrorDuringSendEvent(System.String,System.String)">
            <summary>
            Invoke Error message which occured during sending of the transaction
            </summary>
            <param name="errorMessage">Error message content</param>
            <param name="title">Title of the event message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.InvokeErrorEvent(System.String,System.String)">
            <summary>
            Invoke Common Error message
            </summary>
            <param name="errorMessage">Error message content</param>
            <param name="title">Title of the event message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.TxCashPreload">
            <summary>
            This function will take all utxos and try to request all their txinfo and metadata info as parallel as possible
            The responses from the Neblio API are stored in the cashe, so most of them are not need to call anymore and they will be taken from the memory
            This speed up a loading a lot
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.LoadAccountKey(System.String,System.String)">
            <summary>
            Load account Key. If there is password it is used to decrypt the private key
            This function will load Secret property with Key
            </summary>
            <param name="password">Passwotd to decrypt the loaded private key</param>
            <param name="key">Private Key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ReloadTokenSupply">
            <summary>
            Reload actual token supplies based on already loaded list of address utxos
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ReloadCountOfNFTs">
            <summary>
            Reload actual count of the NFTs based on already loaded list of address utxos
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ReloadMintingSupply">
            <summary>
            Reload actual VENFT minting supply based on already loaded list of address utxos
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ReloadCoruzantNFTs">
            <summary>
            Reload coruzant NFTs list
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ReloadHardwarioNFTs">
            <summary>
            Reload hardwario NFTs list
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ReloadUtxos">
            <summary>
            Reload address Utxos list. It will sort descending the utxos based on the utxos time stamps.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ReloadAccountInfo">
            <summary>
            This function will load actual address info an adress utxos. It is used mainly for loading list of all transactions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ReLoadNFTs(System.Boolean,System.Boolean)">
            <summary>
            This function will reload changes in the NFTs list based on provided list of already loaded utxos.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.RefreshAddressReceivedPayments">
            <summary>
            This function will search NFT Payments in the NFTs list and load them into ReceivedPayments list. 
            This list is cleared at the start of this function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.FireNFTAddedToPayments(System.String,System.ValueTuple{System.String,System.Int32})">
            <summary>
            Redirect of the Event about added NFT to the payments
            It can inform asap UI to block buy of the NFT if it is just original
            </summary>
            <param name="address">Address of the SubAccount</param>
            <param name="e">Utxo hash and Utxo Index</param>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.RefreshAddressReceivedReceipts">
            <summary>
            This function will search NFT Receipts in the NFTs list and load them into ReceivedReceipts list. 
            This list is cleared at the start of this function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.HasSomeSpendableNeblio(System.Double)">
            <summary>
            This function will check if the address has some spendable neblio for transaction.
            </summary>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.HasSomeSourceForMinting">
            <summary>
            This function will check if the address has some spendable VENFT tokens for minting. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ValidateNFTUtxo(System.String,System.Int32)">
            <summary>
            This function will validate if the NFT of this address is spendable
            </summary>
            <param name="utxo">Utxo hash</param>
            <param name="index">index of the Utxo</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.CheckSpendableNeblio(System.Double)">
            <summary>
            This function will check if there is some spendable neblio of specific amount and returns list of the utxos for the transaction
            </summary>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.CheckSpendableNeblioTokens(System.String,System.Int32)">
            <summary>
            This function will check if there is some spendable tokens of specific Id and amount and returns list of the utxos for the transaction.
            </summary>
            <param name="id"></param>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.VerifyMessage(System.String,System.String,System.String,NBitcoin.PubKey)">
            <summary>
            Verify message which was signed by some address.
            </summary>
            <param name="message">Input message</param>
            <param name="signature">Signature of this message created by owner of some address.</param>
            <param name="address">Neblio address which should sign the message and should be verified.</param>
            <param name="bobPubKey">You must fill address or PubKey. If you will fill the PubKey function is much faster</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.EncryptMessage(System.String)">
            <summary>
            Encrypt message with use of ECDSA
            </summary>
            <param name="message">Input message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.DecryptMessage(System.String)">
            <summary>
            Decrypt message with use of ECDSA
            </summary>
            <param name="emessage">Input message</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.GetNFTVerifyCode(System.String)">
            <summary>
            Obtain verify code of some transaction. This will combine txid and UTC time (rounded to minutes) and sign with the private key.
            It will create unique code, which can be verified and it is valid just one minute.
            </summary>
            <param name="txid"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.GetNFTVerifyQRCode(System.String)">
            <summary>
            Verification function for the NFT ownership code generated by GetNFTVerifyCode function.
            </summary>
            <param name="txid"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SignMessage(System.String)">
            <summary>
            Sign custom message with use of account Private Key
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SendNeblioPayment(System.String,System.Double,System.String)">
            <summary>
            Send classic neblio payment
            </summary>
            <param name="receiver">Receiver Neblio Address</param>
            <param name="amount">Ammount in Neblio</param>
            <param name="message">Message in transaction data</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SendMultipleInputNeblioPayment(System.String,System.Double,System.Collections.Generic.List{VEDriversLite.NeblioAPI.Utxos},System.String)">
            <summary>
            Send multiuple input neblio payment
            </summary>
            <param name="receiver">Receiver Neblio Address</param>
            <param name="amount">Ammount in Neblio</param>
            <param name="utxos">Input utxos</param>
            <param name="message">Message in transaction data</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SplitNeblioCoin(System.Collections.Generic.List{System.String},System.Int32,System.Double)">
            <summary>
            Split neblio coin to smaller coins
            </summary>
            <param name="receivers">Receivers list of Neblio Address</param>
            <param name="lots">Number of the lots</param>
            <param name="amount">Amount of new splited couns</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SendNeblioTokenPayment(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.Int32)">
            <summary>
            Send classic token payment. It must match same requirements as minting. It cannot use 1 token inputs (NFTs).
            </summary>
            <param name="tokenId">Token Id hash</param>
            <param name="metadata">Custom metadata</param>
            <param name="receiver">Receiver Neblio address</param>
            <param name="amount">Amount of the tokens</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SplitTokens(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.List{System.String},System.Int32,System.Int32)">
            <summary>
            Send split token payment. It will create multiple outputs with lots of tokens.
            It must match same requirements as minting. It cannot use 1 token inputs (NFTs).
            </summary>
            <param name="tokenId">Token Id hash</param>
            <param name="metadata">Custom metadata</param>
            <param name="receivers">List Receiver Neblio address</param>
            <param name="lots">Amount of the tokens</param>
            <param name="amount">Amount of the tokens</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.MintNFT(VEDriversLite.NFT.INFT,System.String)">
            <summary>
            Mint new NFT. It is automatic function which will decide what NFT to mint based on provided type in the NFT input
            </summary>
            <param name="NFT">Input carrier of NFT data. It must specify the type</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.MintMultiNFT(VEDriversLite.NFT.INFT,System.Int32,System.String)">
            <summary>
            Mint new multi NFT. It is automatic function which will decide what NFT to mint based on provided type in the NFT input.
            </summary>
            <param name="NFT">Input carrier of NFT data. It must specify the type</param>
            <param name="coppies">Number of coppies. 1 coppy means 2 final NFTs</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.MintMultiNFTLargeAmount(VEDriversLite.NFT.INFT,System.Int32,System.String,System.Collections.Generic.List{System.String},System.Int32)">
            <summary>
            Mint new multi NFT. It is automatic function which will decide what NFT to mint based on provided type in the NFT input.
            </summary>
            <param name="NFT">Input carrier of NFT data. It must specify the type</param>
            <param name="coppies">Number of coppies. 1 coppy means 2 final NFTs</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.DestroyNFTs(System.Collections.Generic.ICollection{VEDriversLite.NFT.INFT},System.String)">
            <summary>
            This function will destroy provided NFTs. It means it will connect them again to one output/lot of tokens.
            Now it is possible to destroy just same kind of tokens. The first provided NFT will define TokenId. Different tokensIds will be skipped.
            Maximum to destroy in one transaction is 10 of NFTs
            </summary>
            <param name="nfts">List of NFTs</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SendNFT(System.String,VEDriversLite.NFT.INFT,System.Boolean,System.Double,System.Boolean,System.Double)">
            <summary>
            Send input NFT to new owner, or use it just for price write and resend it to yourself with new metadata about the price.
            </summary>
            <param name="receiver">If the pricewrite is set, this is filled with own address</param>
            <param name="NFT"></param>
            <param name="priceWrite">Set this if you need to just write the price to the NFT</param>
            <param name="price">Price must be bigger than 0.0002 NEBL</param>
            <param name="withDogePrice">Set this if you need to just write the Doge price to the NFT</param>
            <param name="dogeprice">Price must be bigger than 0.1 Doge</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ChangeNFT(VEDriversLite.NFT.INFT)">
            <summary>
            Change Post NFT. It requeires previous loadedPost NFT as input.
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SendIoTMessageNFT(VEDriversLite.NFT.INFT,System.String,System.String)">
            <summary>
            Send NFT.
            </summary>
            <param name="NFT">NFT to sent</param>
            <param name="sender">Sender of the NFT</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SendMessageNFT(System.String,System.String,System.String,System.String,System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>
            Send NFT Message.
            </summary>
            <param name="name">Name of the Message</param>
            <param name="message">Content of the Message</param>
            <param name="receiver">Receiver of the Message</param>
            <param name="utxo">original NFT Utxo - reply for the existing message</param>
            <param name="text">Longer text in the message</param>
            <param name="imagelink">Image link in the message</param>
            <param name="link">Link in the message</param>
            <param name="rewriteAuthor">Rewrite author of the message. Common is the sender (you can use txid of some NFT Profil, etc.)</param>
            <param name="encrypt">Encrypt the message with the shared secret</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.UseNFTTicket(VEDriversLite.NFT.INFT)">
            <summary>
            Write Used flag into NFT Ticket
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SendNFTPayment(System.String,VEDriversLite.NFT.INFT)">
            <summary>
            This function will send payment for some specific NFT which is from foreign address.
            </summary>
            <param name="receiver">Receiver - owner of the NFT</param>
            <param name="NFT">NFT what you want to buy</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.ReturnNFTPayment(System.String,VEDriversLite.NFT.PaymentNFT)">
            <summary>
            This function will return the NFT Payment to the original sender.
            The receiver is taken from the Minting transaction of the PaymentNFT
            </summary>
            <param name="NFT">NFT Payment to return</param>
            <param name="receiver">Receiver of the returned NFT Payment</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SendAirdrop(System.String,System.String,System.Double,System.Double)">
            <summary>
            This function will send airdrop.
            </summary>
            <param name="receiver">Receiver - owner of the NFT</param>
            <param name="tokenId">TokenId of the NTP1 token on Neblio network</param>
            <param name="tokenAmount">Number of the tokens in the airdrop</param>
            <param name="neblioAmount">Neblio amount in the airdrop</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.SendCoruzantNFT(System.String,VEDriversLite.NFT.INFT,System.Boolean,System.String)">
            <summary>
            Add comment to Coruzant Post NFT or add comment and send it to new owner
            </summary>
            <param name="receiver">Fill when you want to send to different address</param>
            <param name="NFT"></param>
            <param name="commentWrite">Set this if you need to just write the comment to the NFT</param>
            <param name="comment">Add your comment</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.InitAllAutoIoTDeviceNFT">
            <summary>
            Init NFT IoT Devices automatically if they have allowed this function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.InitIoTDeviceNFT(System.String,System.Int32)">
            <summary>
            Init IoT Device manually
            </summary>
            <param name="utxo"></param>
            <param name="utxoindex"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.DeInitIoTDeviceNFT(System.String,System.Int32)">
            <summary>
            Deactivate the IoT Device
            </summary>
            <param name="utxo"></param>
            <param name="utxoindex"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioAccountBase.CheckPayments">
            <summary>
            This function will check payments and try to find them complementary NFT which was sold. 
            If there is price mathc and enough of confirmations it will try to send NFT to new owner.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Neblio.NeblioSubAccount">
            <summary>
            Neblio Sub Account. It has some limited functions. It is usually loaded under NeblioAccount
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioSubAccount.EKey">
            <summary>
            Encrypted Private Key with use of the NBitcoin alg. with main public key enc and private key dec
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioSubAccount.ESKey">
            <summary>
            Encrypted Private Key with use of SHA256 hash of main private key and AES256
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioSubAccount.Name">
            <summary>
            Name of the Sub Account
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioSubAccount.IsAutoRefreshActive">
            <summary>
            When this flag is set, account reload the Utxos state - inside autorefresh
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioSubAccount.BookmarkFromAccount">
            <summary>
            Bookmark related to this Sub Account loaded from the Main account if exist
            </summary>
        </member>
        <member name="P:VEDriversLite.Neblio.NeblioSubAccount.IsInBookmark">
            <summary>
            Indicate if this Sub Account is in the Bookmark
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioSubAccount.NewMintingProcessInfo">
            <summary>
            This event is called whenever some progress during multimint happens
            </summary>
        </member>
        <member name="E:VEDriversLite.Neblio.NeblioSubAccount.FirsLoadingStatus">
            <summary>
            This event is called during first loading of the account to keep updated the user
            </summary>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioSubAccount.CreateAddress(NBitcoin.BitcoinSecret,System.String)">
            <summary>
            Create Sub Account Address and Private Key
            The Account Private key is encrypted with use of main account private key
            </summary>
            <param name="mainSecret">Main Account Private Key</param>
            <param name="name">Name of the Sub Account</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioSubAccount.LoadFromBackupString(NBitcoin.BitcoinSecret,System.String)">
            <summary>
            Load Sub Account from the string with AcountExportDto data
            </summary>
            <param name="mainSecret"></param>
            <param name="inputData">serialized AcountExportDto</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioSubAccount.LoadFromBackupDto(NBitcoin.BitcoinSecret,VEDriversLite.Dto.AccountExportDto)">
            <summary>
            Load Sub Account from AcountExportDto
            </summary>
            <param name="mainSecret"></param>
            <param name="dto">account export data</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioSubAccount.BackupAddressToString">
            <summary>
            Backup Sub Account data as serialized AcountExportDto
            </summary>
            <returns>true and serialized AcountExportDto</returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioSubAccount.BackupAddressToDto">
            <summary>
            Backup Sub Account to AcountExportDto
            </summary>
            <returns>true and AcountExportDto</returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioSubAccount.LoadBookmark(VEDriversLite.Bookmarks.Bookmark)">
            <summary>
            Load bookmark
            </summary>
            <param name="bkm"></param>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioSubAccount.ClearBookmark">
            <summary>
            Clear bookmark object
            </summary>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioSubAccount.StartRefreshingData(System.Int32)">
            <summary>
            This function will load the actual data and then run the task which periodically refresh this data.
            It doesnt have cancellation now!
            </summary>
            <param name="interval">Default interval is 3000 = 3 seconds</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Neblio.NeblioTransactionsCache">
            <summary>
            This class will query Neblio API with the input address, stores the BlockHeight from address's latest Utxo in Cache.
            Cache will expiry for every 10 seconds so when accessed system will check cache and return the latest blockheight 
            </summary>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioTransactionsCache.LatestBlockHeight(System.String,System.String)">
            <summary>
            Method will check if the data for current address is available in cache and returns the blockheight, IF not avaialble then retrievs from API.
            </summary>
            <param name="address">The address for which we need the latest block height</param>
            <param name="utxo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Neblio.NeblioTransactionsCache.SetChacheValue(System.String,System.Object)">
            <summary>
            Set value in the cache
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:VEDriversLite.NeblioTransactionHelpers">
            <summary>
            Main Helper class for the Neblio Blockchain Transactions
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.TurnOnCache">
            <summary>
            Turn on and off of the cache for address info, transaction info and metadata of the transaction
            If it is true the cache is on. It is default state.
            Usually it is important to turn it off just for unit tests which uses simulated address and tx data
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.FromSatToMainRatio">
            <summary>
            Conversion ration for Neblio to convert from sat to 1 NEBL
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.MaximumTokensOutpus">
            <summary>
            Maximum number of outputs which carry some token in the Neblio transaction
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.MaximumNeblioOutpus">
            <summary>
            Maximum number of outputs without tokens in the Neblio transaction
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.Network">
            <summary>
            NBitcoin Instance of Mainet Network of Neblio
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.MinimumConfirmations">
            <summary>
            Minimum number of confirmation to send the transaction
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.MinimumAmount">
            <summary>
            Minimum amount in Satoshi on Neblio Blockchain
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.TokensInfo">
            <summary>
            Tokens Info for all already loaded tokens
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.TransactionInfoCache">
            <summary>
            Transaction info cache. If the tx was already loaded it will remember it if it has more than MinimumConfirmations
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.TokenTxMetadataCache">
            <summary>
            Token metadata cache. It is same all the time for the specific hash of the tx
            </summary>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.AddressInfoCache">
            <summary>
            Address info cache. It will save for at least one second address info. If it is older, it will reqeuest new info.
            </summary>
        </member>
        <member name="E:VEDriversLite.NeblioTransactionHelpers.NewEventInfo">
            <summary>
            Main event info handler
            </summary>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.ShortenAddress(System.String)">
            <summary>
            Create short version of address, 3 chars on start...3 chars on end
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.ShortenTxId(System.String,System.Boolean,System.Int32)">
            <summary>
            Create short version of txid hash, 3 chars on start...3 chars on end
            </summary>
            <param name="txid"></param>
            <param name="withDots">default true. add .... between start and end of the tx hash</param>
            <param name="len">Length of the result shortened tx hash</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.LoadAllowedTokensInfo(System.Collections.Generic.List{System.String})">
            <summary>
            Load informations about allowed tokens.
            </summary>
            <param name="tokenIds">List of allowed tokens to works with.</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetAddressAndKey(VEDriversLite.Security.EncryptionKey,System.String)">
            <summary>
            Function converts EncryptionKey (optionaly with password if it is not already loaded in ekey)
            and returns BitcoinAddress and BitcoinSecret classes from NBitcoin
            </summary>
            <param name="ekey"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetAddressAndKey(VEDriversLite.Security.EncryptionKey)">
            <summary>
            Function converts EncryptionKey (optionaly with password if it is not already loaded in ekey)
            and returns BitcoinAddress and BitcoinSecret classes from NBitcoin
            </summary>
            <param name="ekey"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.BroadcastSignedTransaction(System.String)">
            <summary>
            Function will take hex of signed transaction and broadcast it via Neblio API
            </summary>
            <param name="txhex"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetSendTokenObject(System.Double,System.Double,System.String,System.String)">
            <summary>
            Function prepares SendTokenRequest object. It is important to initialitze correct inside properties
            </summary>
            <param name="amount">Amount to send</param>
            <param name="fee">Fee - min 10000, with metadata you need at least 20000</param>
            <param name="receiver">Receiver of the amount</param>
            <param name="tokenId">Token Id hash</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.CalcFee(System.Int32,System.Int32,System.String,System.Boolean)">
            <summary>
            This function will calculate the fee based of the known lenght of the intputs and the outputs
            If there is the OP_RETURN output it is considered as the customMessage. Please fill it for token transactions.
            Token transaction also will add just for sure one output to calculation of the size for the case there will be some tokens back to original address
            </summary>
            <param name="numOfInputs">Number of input of the transaction "in" vector</param>
            <param name="numOfOutputs">Number of outpus of the transaction "out" vector</param>
            <param name="customMessageInOPReturn">Custom message - "OP_RETURN" output</param>
            <param name="isTokenTransaction">Token transaction will add another output for getting back the tokens</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTransactionWithNeblioInputs(System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},NBitcoin.BitcoinAddress)">
            <summary>
            This function will crate empty Transaction object based on Neblio network standard
            Then add the Neblio Inputs and sumarize their value
            </summary>
            <param name="nutxos">List of Neblio Utxos to use</param>
            <param name="address">Address of the owner</param>
            <returns>(NBitcoin Transaction object, sum of all inputs values in double)</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.MintNFTTokenAsync(VEDriversLite.MintNFTData,VEDriversLite.Security.EncryptionKey,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            Function will Mint NFT from lot of the tokens
            </summary>
            <param name="data">Mint data, please see MintNFTData class for the details</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="tutxos">Optional input token utxo</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.MintMultiNFTTokenAsync(VEDriversLite.MintNFTData,System.Int32,VEDriversLite.Security.EncryptionKey,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            Function will Mint NFT with the coppies
            </summary>
            <param name="data">Mint data, please see MintNFTData class for the details</param>
            <param name="coppies">0 or more coppies - with 0 input it is same as MintNFTTokenAsync</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="tutxos">Optional input token utxo</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.MintMultiNFTTokenAsyncInternal(VEDriversLite.MintNFTData,System.Int32,VEDriversLite.Security.EncryptionKey,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Boolean)">
            <summary>
            Function will Mint NFT with the coppies
            </summary>
            <param name="data">Mint data, please see MintNFTData class for the details</param>
            <param name="coppies">0 or more coppies - with 0 input it is same as MintNFTTokenAsync</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="tutxos">Optional input token utxo</param>
            <param name="multiTokens">If there is the multi token it needs to check if there is no conflict</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.SplitNTP1TokensAsync(System.Collections.Generic.List{System.String},System.Int32,System.Int32,System.String,System.Collections.Generic.IDictionary{System.String,System.String},VEDriversLite.Security.EncryptionKey,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            Function will Split NTP1 tokens to smaller lots
            receiver list - If you input 0, split will be done to sender address, if you input 1 receiver split will be done to receiver (all inputs)
            if you will provide multiple receivers, the number of lots and receivers must match.
            </summary>
            <param name="receiver">List of receivers. </param>
            <param name="lots"></param>
            <param name="amount"></param>
            <param name="tokenId"></param>
            <param name="metadata"></param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="tutxos">Optional input token utxo</param>
            <param name="fee">Fee - 20000 minimum</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.SendNFTTokenAsync(VEDriversLite.SendTokenTxData,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            Function will sent exact NFT. 
            You must fill the input token utxo in data object!
            </summary>
            <param name="data">Send data, please see SendTokenTxData class for the details</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="fee">Fee - 20000 minimum</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.SendTokenLotAsync(VEDriversLite.SendTokenTxData,VEDriversLite.Security.EncryptionKey,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Double)">
            <summary>
            Function will send lot of tokens (means more than 1) to some address
            </summary>
            <param name="data">Send data, please see SendtokenTxTData class for the details</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="tutxos">Optional input token utxo</param>
            <param name="fee">Fee - 20000 minimum</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetNeblioTransactionObject(VEDriversLite.SendTxData,VEDriversLite.Security.EncryptionKey,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            Function will send standard Neblio transaction
            </summary>
            <param name="data">Send data, please see SendTxData class for the details</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="fee">Fee - 10000 minimum</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.SplitNeblioCoinTransactionAPIAsync(System.Collections.Generic.List{System.String},System.Int32,System.Double,VEDriversLite.Security.EncryptionKey,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            Function will send standard Neblio transaction
            </summary>
            <param name="sender"></param>
            <param name="receivers"></param>
            <param name="lots"></param>
            <param name="amount"></param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="fee">Fee - 10000 minimum</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.SendNTP1TokenWithPaymentAPIAsync(VEDriversLite.SendTokenTxData,VEDriversLite.Security.EncryptionKey,System.Double,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.String,System.Int32)">
            <summary>
            This function will send Neblio payment together with the token whichc carry some metadata
            </summary>
            <param name="data">Mint data, please see MintNFTData class for the details</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="neblAmount">Amount of Neblio to send</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="paymentUtxoToReturn">If you returning some payment fill this</param>
            <param name="paymentUtxoIndexToReturn">If you returning some payment fill this</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.SendNTP1TokenLotWithPaymentAPIAsync(VEDriversLite.SendTokenTxData,VEDriversLite.Security.EncryptionKey,System.Double,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            This function will send Neblio payment together with the token whichc carry some metadata
            </summary>
            <param name="data">Mint data, please see MintNFTData class for the details</param>
            <param name="ekey">Input EncryptionKey of the account</param>
            <param name="neblAmount">Amount of Neblio to send</param>
            <param name="nutxos">Optional input neblio utxo</param>
            <param name="tutxos">Optional list of the token utxos </param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.SignAndBroadcast(NBitcoin.Transaction,NBitcoin.BitcoinSecret)">
            <summary>
            Function will sign transaction with provided key and broadcast with Neblio API
            </summary>
            <param name="transaction">NBitcoin Transaction object</param>
            <param name="key">NBitcoin Key - must contain Private Key</param>
            <param name="address">NBitcoin address - must match with the provided key</param>
            <returns>New Transaction Hash - TxId</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.SendMultiTokenAPIAsync(VEDriversLite.SendTokenTxData,VEDriversLite.Security.EncryptionKey,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Double,System.Boolean)">
            <summary>
            Transaction which sends multiple tokens from input to different outputs. For example process of the send Ordered NFT and NFT Receipt in one tx.
            </summary>
            <param name="data"></param>
            <param name="ekey"></param>
            <param name="nutxos"></param>
            <param name="fee"></param>
            <param name="isMintingOfCopy"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.DestroyNFTAsync(VEDriversLite.SendTokenTxData,VEDriversLite.Security.EncryptionKey,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Double,VEDriversLite.NeblioAPI.Utxos)">
            <summary>
            Destroy of the NFT. It merge the NFT with the minting lot
            1VENFT + 10VENFT => 11 VENFT
            </summary>
            <param name="data"></param>
            <param name="ekey"></param>
            <param name="nutxos"></param>
            <param name="fee"></param>
            <param name="mintingUtxo"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.IsPrivateKeyValid(System.String)">
            <summary>
            Check if the private key is valid for the Neblio Network
            </summary>
            <param name="privatekey"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetAddressFromPrivateKey(System.String)">
            <summary>
            Parse the Neblio address from the private key
            </summary>
            <param name="privatekey"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.ValidateNeblioAddress(System.String)">
            <summary>
            Validate if the Neblio address is the correct
            </summary>
            <param name="neblioAddress"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.IsEnoughConfirmationsForSend(System.Int32)">
            <summary>
            Check if the number of the confirmation is enough for doing transactions.
            It mainly usefull for UI stuff or console.
            </summary>
            <param name="confirmations"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetClient">
            <summary>
            Returns private client for Neblio API. If it is null, it will create new instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetClient(VEDriversLite.NeblioAPI.IClient)">
            <summary>
            This method is written for Unit tests to pass in Mock client object
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.SendRawNTP1TxAsync(VEDriversLite.NeblioAPI.SendTokenRequest)">
            <summary>
            Send request for creating RAW token transaction
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.BroadcastNTP1TxAsync(VEDriversLite.NeblioAPI.BroadcastTxRequest)">
            <summary>
            Broadcast of signed transaction. Works for Neblio and Token transactions.
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.AddressInfoAsync(System.String)">
            <summary>
            Return Address info object. Contains list of all transactions
            </summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.AddressInfoUtxosAsync(System.String)">
            <summary>
            Return address info object. this object contains list of Utxos.
            </summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetAddressUtxosObjects(System.String)">
            <summary>
            Return list of Utxos object.
            </summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetAddressTokensUtxos(System.String,VEDriversLite.NeblioAPI.GetAddressInfoResponse)">
            <summary>
            Returns list of all Utxos which contains some tokens
            </summary>
            <param name="addr"></param>
            <param name="addressinfo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTxHex(System.String)">
            <summary>
            Return transaction Hex
            </summary>
            <param name="txid"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetAddressNFTsUtxos(System.String,System.Collections.Generic.List{System.String},VEDriversLite.NeblioAPI.GetAddressInfoResponse)">
            <summary>
            Returns list of all Utxos which contains just one token, means amount = 1
            </summary>
            <param name="addr"></param>
            <param name="allowedTokens">Load just the allowed tokens</param>
            <param name="addressinfo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetSendAmount(VEDriversLite.NeblioAPI.GetTransactionInfoResponse,System.String)">
            <summary>
            Returns sended amount of neblio in some transaction. It counts the outputs which was send to input address
            </summary>
            <param name="tx"></param>
            <param name="address">expected address where was nebl send in this tx</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetAddressNeblUtxo(System.String,System.Double,System.Double,VEDriversLite.NeblioAPI.GetAddressInfoResponse,System.Double)">
            <summary>
            Returns list of spendable utxos which together match some input required amount for some transaction
            </summary>
            <param name="address">address which has utxos for spend - sender in tx</param>
            <param name="addinfo">If you already have loaded addinfo pass it</param>
            <param name="latestBlockHeight"></param>
            <param name="minAmount">minimum amount of one utxo</param>
            <param name="requiredAmount">amount what must be collected even by multiple utxos</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.ValidateOneTokenNFTUtxo(System.String,System.String,System.String,System.Int32,VEDriversLite.NeblioAPI.GetAddressInfoResponse,System.Double)">
            <summary>
            Check if the NFT token is spendable. Means utxos with token amount = 1
            </summary>
            <param name="address">address which should have this utxo</param>
            <param name="addinfo">if you already have addinfo pass it</param>
            <param name="latestBlockHeight"></param>
            <param name="tokenId">input token id hash</param>
            <param name="txid">input txid hash</param>
            <param name="indx"></param>
            <returns>true and index of utxo</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.FindUtxoForMintNFT(System.String,System.String,System.Int32,System.Double,VEDriversLite.NeblioAPI.GetAddressInfoResponse,System.Double)">
            <summary>
            Find utxo which can be used for minting. It means it has token amount > 1
            </summary>
            <param name="addr">address which has utxos</param>
            <param name="tokenId">token id hash</param>
            <param name="numberToMint">number of tokens which will be minted - because of multimint</param>
            <param name="oneTokenSat">this is usually default. On Neblio all token tx should have value 10000sat</param>
            <param name="addinfo"></param>
            <param name="latestBlockHeight"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTokenMetadataOfUtxoCache(System.String,System.String,System.Double)">
            <summary>
            Get token metadata from the specific transaction cache logic
            </summary>
            <param name="tokenid"></param>
            <param name="txid"></param>
            <param name="verbosity"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTransactionMetadata(System.String,System.String)">
            <summary>
            Returns metadata in the token transction
            </summary>
            <param name="tokenid">token id hash</param>
            <param name="txid">tx id hash</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetLastSentTransaction(System.String)">
            <summary>
            Find last send transaction by some address.
            This is usefull to obtain address public key from signature of input.
            </summary>
            <param name="address">Searched address</param>
            <returns>NBitcoin Transaction object</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTransactionInfo(System.String)">
            <summary>
            Get transaction info.
            </summary>
            <param name="txid">tx id hash</param>
            <returns>Neblio API GetTransactionInfo object</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTransactionInternal(System.String,System.String,VEDriversLite.NeblioAPI.GetTransactionInfoResponse)">
            <summary>
            
            </summary>
            <param name="txid"></param>
            <param name="mode"></param>
            <param name="txinfo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTransactionSender(System.String,VEDriversLite.NeblioAPI.GetTransactionInfoResponse)">
            <summary>
            Get transaction sender.
            </summary>
            <param name="txid">tx id hash</param>
            <param name="txinfo">if you already have txinfo object</param>
            <returns>Sender address</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTransactionReceiver(System.String,VEDriversLite.NeblioAPI.GetTransactionInfoResponse)">
            <summary>
            Get transaction sender.
            </summary>
            <param name="txid">tx id hash</param>
            <param name="txinfo">if you already have txinfo object</param>
            <returns>Sender address</returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.ParseNeblioMessage(VEDriversLite.NeblioAPI.GetTransactionInfoResponse)">
            <summary>
            Parse message from the OP_RETURN data in the tx
            </summary>
            <param name="txinfo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.HexStringToBytes(System.String)">
            <summary>
            Convert the hex string to bytes
            </summary>
            <param name="hexString"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="F:VEDriversLite.NeblioTransactionHelpers.TokenMetadataCache">
            <summary>
            Token Metadata cache list
            </summary>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTokenMetadata(System.String)">
            <summary>
            Get token issue metadata. Contains image url, issuer, and other info
            </summary>
            <param name="tokenId">token id hash</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTokenInfo(System.String)">
            <summary>
            Get token info. Contains image url, issuer, and other info
            </summary>
            <param name="tokenId">token id hash</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetActualMintingSupply(System.String,System.String,VEDriversLite.NeblioAPI.GetAddressInfoResponse)">
            <summary>
            check actual supply for minting on some address. It is just for VENFT tokens now. 
            Function will also load token metadta if it has not loaded yet.
            </summary>
            <param name="address">address which has utxos</param>
            <param name="tokenId">Specify the tokenId</param>
            <param name="addressinfo">if you have already loaded address info with utxo list provide it to prevent unnecessary API requests</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.CheckTokensSupplies(System.String,VEDriversLite.NeblioAPI.GetAddressInfoResponse)">
            <summary>
            Check supply of all tokens on address.
            </summary>
            <param name="address">address which has utxos</param>
            <param name="addressinfo">if you have already loaded address info with utxo list provide it to prevent unnecessary API requests</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTokenOwnersList(System.String)">
            <summary>
            Return VENFT top owners. It eliminate some testing addresses.
            </summary>
            <param name="tokenId">Token Id hash</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NeblioTransactionHelpers.GetTokenOwners(System.String)">
            <summary>
            Return VENFT top owners. It eliminate some testing addresses.
            </summary>
            <param name="tokenId">Token Id hash</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.CommonNFT">
            <summary>
            Common NFT class. It implements lots of functions for the parsing the basic parameter of the NFT.
            It contains also functions to decrypt or encrypt the property
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.TypeText">
            <summary>
            Text form of the NFT type like "NFT Image" or "NFT Post"
            The parsing is in the Common NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Type">
            <summary>
            NFT Type by enum of NFTTypes
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Name">
            <summary>
            Name of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Author">
            <summary>
            Author of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Description">
            <summary>
            Description of the NFT - for longer text please use the "Text" property
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Text">
            <summary>
            Text of the NFT - prepared for the longer texts
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Link">
            <summary>
            Link to some webiste in the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.IconLink">
            <summary>
            Link to the icon of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.ImageLink">
            <summary>
            Link to the image in the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.ImageData">
            <summary>
            Loaded Image data as byte array
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Preview">
            <summary>
            Preview data of image or music
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.PreviewData">
            <summary>
            Loaded Image Preview data as byte array
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.DataItems">
            <summary>
            More items in the NFT, for example Image gallery with more images than one
            Probably future replacement of the "ImageLink" property
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.CommonNFT._tags">
            <summary>
            List of the tags separated by space
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.TagsList">
            <summary>
            Parsed tag list. It is parsed in Common NFT class
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Utxo">
            <summary>
            NFT Utxo hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.UtxoIndex">
            <summary>
            NFT Utxo Index
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.ShortHash">
            <summary>
            Shorten hash including index number
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.NFTOriginTxId">
            <summary>
            NFT Origin transaction hash - minting transaction in the case of original NFTs (Image, Music, Ticket)
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.SourceTxId">
            <summary>
            Source tx where the input for the NFT Minting was taken
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.TokenId">
            <summary>
            Id of the token on what the NFT is created
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Price">
            <summary>
            Price of the NFT in the Neblio
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.PriceActive">
            <summary>
            PriceActive is setted automatically when the price is setted up
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.DogePrice">
            <summary>
            Price of the NFT in the Dogecoin
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.DogePriceActive">
            <summary>
            DogePriceActive is setted automatically when the price is setted up
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.DogeAddress">
            <summary>
            Related Doge Address to this NFT. If it is created by VENFT App it is filled automatically during the minting request
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.SellJustCopy">
            <summary>
            Set that this NFT will be sold as just in coppies minted for the buyer
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.IsLoaded">
            <summary>
            If the NFT is fully loaded this flag is set
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.IsInThePayments">
            <summary>
            If the NFT is alredy saw in the payment this is set
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.DogeftInfo">
            <summary>
            Info for publishing NFT to the Dogeft
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.SoldInfo">
            <summary>
            If the NFT is sold this will be filled
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.Time">
            <summary>
            DateTime stamp taken from the blockchain trnsaction
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.History">
            <summary>
            History of this NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.CommonNFT.TxDetails">
            <summary>
            The transaction info details
            </summary>
        </member>
        <member name="E:VEDriversLite.NFT.CommonNFT.TxDataRefreshed">
            <summary>
            This event is fired when the transaction info is refreshed
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse the origin data of the NFT.
            It will track the NFT to its origin and use the data from the origin
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Retrive the Metadata of the actual NFT. 
            It will take the correct properties and translate them to the dictionary which can be add to the token transaction metdata
            If the NFT contains encrypted metadata with use of Shared Secret (EDCH) like NFT Message you must provide the parameters if you need to do encryption
            </summary>
            <param name="address">Address of the sender of the NFT</param>
            <param name="key">Private key of the sender of the NFT</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill common and specific properties of the NFT
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific information related to the specific kind of the NFT. 
            This function must be overwritte in specific NFT class
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.IsSpendable">
            <summary>
            Return info if the transaction is spendable
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.LoadHistory">
            <summary>
            Load NFT history.
            It will load fully all history steps of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.FillCommon(VEDriversLite.NFT.INFT)">
            <summary>
            Fill common properties for the NFT
            </summary>
            <param name="nft"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.ClearSoldInfo">
            <summary>
            Clear the object with SoldInfo of NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.ClearPrices">
            <summary>
            Clear all the prices inside of the NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.ParseTags">
            <summary>
            Function will parse tags to the list of the tags
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.LoadLastData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Load last data of the NFT.
            It means that it will take just the last data and not tracking the origin for the orign data
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.ParsePrice(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse price from the metadata of the NFT
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.ParseSoldInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse info about the sellfrom the metadata of the NFT
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.ParseCommon(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse common properties from the dictionary of metadata
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.ParseDogeftInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse dogeft info from the metadata
            </summary>
            <param name="meta"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.GetCommonMetadata">
            <summary>
            Get common metadata of the NFT as dictionary
            </summary>
            <returns>Dicrionary with preapred common metadata for the NFT transaction</returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.DownloadPreviewData">
            <summary>
            Download preview data if there are some
            </summary>
            <returns>true if success</returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.DownloadImageData">
            <summary>
            Download Image data if there are some
            </summary>
            <returns>true if success</returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.DecryptImageData(NBitcoin.BitcoinSecret,System.String,System.String,System.String)">
            <summary>
            This function will download the data from the IPFS then decrypt the encrypted file container with use of shared secret.
            Then the image is saved in ImageData as bytes.
            </summary>
            <param name="secret">NFT Owner Private Key</param>
            <param name="imageLink"></param>
            <param name="partner"></param>
            <param name="sharedkey"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.DecryptProperty(System.String,NBitcoin.BitcoinSecret,System.String,System.String,System.String)">
            <summary>
            Decrypt the specific property with use of shared secret
            </summary>
            <param name="prop">Property content</param>
            <param name="secret">NFT Owner Private Key</param>
            <param name="address"></param>
            <param name="partner"></param>
            <param name="sharedkey"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.StopRefreshingData">
            <summary>
            Stop the auto refreshin of the tx info data
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.CommonNFT.StartRefreshingTxData(System.Int32)">
            <summary>
            Start auto refreshing of the tx info data
            </summary>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Coruzant.CommonCoruzantNFT">
            <summary>
            Abstract common class for Coruzant NFTs
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CommonCoruzantNFT.PodcastLink">
            <summary>
            Link to the podcast
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT">
            <summary>
            Coruzant specific NFT for the article
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.#ctor(System.String)">
            <summary>
            Construct the NFT Article
            </summary>
            <param name="utxo"></param>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill the NFT with data
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.AuthorProfileUtxo">
            <summary>
            Reference to the Coruzant NFT Profile
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.FullPostLink">
            <summary>
            Full link to previous post
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.LastComment">
            <summary>
            Last added comment to the article
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.LastCommentBy">
            <summary>
            Last comment was added by address or NFT Profile hash
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific properties
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.GetLastData">
            <summary>
            Load last data for this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantArticleNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get Metadata of this NFT
            </summary>
            <param name="address"></param>
            <param name="key"></param>
            <param name="receiver"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:VEDriversLite.NFT.Coruzant.CoruzantBrowser">
            <summary>
            Class which loads just Coruzant NFTs on specific address
            It can handle multiple addresses like browser
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantBrowser.Tabs">
            <summary>
            List of loaded tabs with NFTs
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantBrowser.CoruzantContentAddresses">
            <summary>
            Addresses to load NFTs from
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantBrowser.LoadTabs(System.String)">
            <summary>
            Load tabs from previous serialized string.
            </summary>
            <param name="tabs">List of ActiveTabs as json string</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantBrowser.AddTab(System.String)">
            <summary>
            Add new tab based on some Neblio address
            </summary>
            <param name="address"></param>
            <returns>true and string with serialized tabs list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantBrowser.RemoveTab(System.String)">
            <summary>
            Remove tab by Neblio address if exists in the tabs
            </summary>
            <param name="address">Neblio Address which tab should be removed</param>
            <returns>true and string with serialized tabs list as json string</returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantBrowser.SelectTab(System.String)">
            <summary>
            Select the tab - it will set one selected tab to the Selected=true and others will set false
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantBrowser.SerializeTabs">
            <summary>
            Return serialized list of ActiveTabs as Json stirng
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantBrowser.LoadCoruzantContentAddresses">
            <summary>
            Return list of available Coruzant Content Addresses
            </summary>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Coruzant.CoruzantNFTHelpers">
            <summary>
            Helper class to load and handle Coruzant NFTs
            Will be replaced with INFTModules soon
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantNFTHelpers.CoruzantTokenId">
            <summary>
            Coruzant token ID - CORZT on Neblio Blockchain
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantNFTHelpers.GetCoruzantNFTs(System.Collections.Generic.List{VEDriversLite.NFT.INFT})">
            <summary>
            Filter just Coruzant NFTs from NFT list
            </summary>
            <param name="allNFTs"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantNFTHelpers.FindCoruzantProfileNFT(System.Collections.Generic.ICollection{VEDriversLite.NFT.INFT})">
            <summary>
            This function will return first profile NFT in NFTs list.
            </summary>
            <param name="nfts"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantNFTHelpers.ChangeCoruzantPostNFT(System.String,VEDriversLite.Security.EncryptionKey,VEDriversLite.NFT.INFT,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},NBitcoin.BitcoinSecret,System.String)">
            <summary>
            This function will change Coruzant Post NFT
            You can use this function for sending the NFT when you will fill receiver parameter
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="NFT">Input NFT object with data to save to metadata. Must contain Utxo hash</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <param name="receiver">Fill when you want to send NFT to another address</param>
            <returns>New Tx Id Hash</returns>
        </member>
        <member name="T:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto">
            <summary>
            Dto to serialize information from buzzsprout api
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto.id">
            <summary>
            ID of the episode
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto.title">
            <summary>
            Title of the episode
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto.audio_url">
            <summary>
            Audio url of the episode
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto.artwork_url">
            <summary>
            Image url of the episode
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto.description">
            <summary>
            Description of the episode
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto.summary">
            <summary>
            Short summary of the episode
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto.artist">
            <summary>
            Artists
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto.guid">
            <summary>
            GUID of the episode
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.BuzzsproutEpisodeDto.total_plays">
            <summary>
            Total played
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT">
            <summary>
            Coruzant profile NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.#ctor(System.String)">
            <summary>
            Construct empty Coruzant profile
            </summary>
            <param name="utxo"></param>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.Age">
            <summary>
            Age of the person
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.Surname">
            <summary>
            Person Surname
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.Nickname">
            <summary>
            Person Nickname
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.PersonalPageLink">
            <summary>
            Personal page url link
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.CompanyName">
            <summary>
            Name of the company where person is working
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.CompanyLink">
            <summary>
            Link to the company website
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.WorkingPosition">
            <summary>
            Working position of the person
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.PodcastId">
            <summary>
            Podcast Id with this person
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.Linkedin">
            <summary>
            LinkedIn link of the person
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.Twitter">
            <summary>
            Twitter link of the person
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill the data from template
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse origin data of the NFT
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.GetLastData">
            <summary>
            Get last data for this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantProfileNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get Metadata for this NFT
            </summary>
            <param name="address"></param>
            <param name="key"></param>
            <param name="receiver"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:VEDriversLite.NFT.Coruzant.CoruzantTab">
            <summary>
            Coruzant tab loads the coruzant NFTs
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantTab.#ctor(System.String)">
            <summary>
            Create tab for the specific address which will be loaded
            Constructor will create also shorten version of the address to simplify load to the UI
            </summary>
            <param name="address"></param>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantTab.Selected">
            <summary>
            Tab is selected
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantTab.Address">
            <summary>
            Address loaded on this tab
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantTab.ShortAddress">
            <summary>
            Shorten version of the address
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantTab.IsInBookmark">
            <summary>
            Is set when tab is in the bookmarks of the main account
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantTab.NFTs">
            <summary>
            List of the NFTs loadef on this tab
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantTab.BookmarkFromAccount">
            <summary>
            Loaded bookmark object from the main account
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.CoruzantTab.Profile">
            <summary>
            Coruzant profile NFT        
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantTab.Reload">
            <summary>
            Reload the data        
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantTab.LoadBookmark(VEDriversLite.Bookmarks.Bookmark)">
            <summary>
            Load bookmark object        
            </summary>
            <param name="bkm"></param>
        </member>
        <member name="M:VEDriversLite.NFT.Coruzant.CoruzantTab.ClearBookmark">
            <summary>
            Clear bookmark object
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Coruzant.Dto.CoruzantContentAddressDto">
            <summary>
            Dto for the coruzant address
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.Dto.CoruzantContentAddressDto.Address">
            <summary>
            Address with content
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.Dto.CoruzantContentAddressDto.Name">
            <summary>
            Name of the page - block of the content
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.Dto.CoruzantContentAddressDto.Description">
            <summary>
            Short description of the content
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.Dto.CoruzantContentAddressDto.ImageLink">
            <summary>
            Image link of this block of the content
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.Dto.CoruzantContentAddressDto.ProfileLink">
            <summary>
            Main profile NFT link/hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Coruzant.Dto.CoruzantContentAddressDto.Tags">
            <summary>
            List of the tags describing this content
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.DevicesNFTs.DeviceNFT">
            <summary>
            NFT for description of common device which can be for example some electronic device
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.#ctor(System.String)">
            <summary>
            Create empty device
            </summary>
            <param name="utxo"></param>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.Version">
            <summary>
            Version of the Device
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.ProtocolNFTHash">
            <summary>
            Protocol NFT hash related to this device
            It should describe the communication with the device on public APIs
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.HWSrcNFTHash">
            <summary>
            HW source NFT. Should lead to source of the hardware design
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.FWSrcNFTHash">
            <summary>
            FW source NFT. Should lead to source of the firmware
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.SWSrcNFTHash">
            <summary>
            SW source NFT. Should lead to source of the software
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.MechSrcNFTHash">
            <summary>
            Mechanical source NFT. Should lead to source of the mechanical design
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.MAC">
            <summary>
            MAC address - will be moved to IoT device
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.UniqueId">
            <summary>
            Unique Id of the producet/device
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.LoadedProtocolNFT">
            <summary>
            Loaded protocol NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.HwSourceNFT">
            <summary>
            Loaded HW Source NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.FwSourceNFT">
            <summary>
            Loaded FW Source NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.SwSourceNFT">
            <summary>
            Loaded SW Source NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.MechSourceNFT">
            <summary>
            Loaded Mechanical Source NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill NFT with data from template
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific properties
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse origin properties
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.GetLastData">
            <summary>
            Get last data for this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get metadata of this NFT
            </summary>
            <param name="address"></param>
            <param name="key"></param>
            <param name="receiver"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.DeviceNFT.LoadSourceNFTs">
            <summary>
            Load all source NFTs
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.HardwarioNFTHelpers.GetHARDWARIONFTs(System.Collections.Generic.List{VEDriversLite.NFT.INFT})">
            <summary>
            Filter just Coruzant NFTs from NFT list
            </summary>
            <param name="allNFTs"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT">
            <summary>
            IoT Device NFT - can load the data from the API and resend them as NFT IoTMessages
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.#ctor(System.String)">
            <summary>
            Constructor of the empty NFT IoTDevice
            </summary>
            <param name="utxo"></param>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.DeviceNFTHash">
            <summary>
            Related NFT Device hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.Address">
            <summary>
            Address of the owner of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.ReceivingMessageAddress">
            <summary>
            Address where should NFT IoTDevice send the NFT IoTMessages when some new is available
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.IoTDataDriverTypeText">
            <summary>
            Type of the driver as text
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.IoTDDType">
            <summary>
            Type of the driver
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.IDDSettings">
            <summary>
            Loaded IoT Data Driver Settings with parameters for the connection to the API
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.AutoActivation">
            <summary>
            Activate automatically the NFT when it is loaded on some address
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.EncryptSetting">
            <summary>
            Encrypted settings. It will encrypt the settings with use of the BitcoinSecret
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.EncryptMessages">
            <summary>
            Set if you want to encrypt all sent messages
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.Location">
            <summary>
            Location name
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.LocationCoordinates">
            <summary>
            Location coordinates string
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.LocationCoordinatesLat">
            <summary>
            Location coordinate Latitude
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.LocationCoordinatesLen">
            <summary>
            Location coordinate Longitude
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.RunJustOwn">
            <summary>
            Run just NFT which was minted on this address or resent to itself on same address
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.AllowConsoleOutputWhenNewMessage">
            <summary>
            Allow output to the console when new message will arrive
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.Active">
            <summary>
            NFT IoTDevice is active and communicate with API
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.DecryptedSetting">
            <summary>
            The settings is already decrypted if this is true
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.MessageNFTs">
            <summary>
            List of all processed messages or messages which should be processed
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.SourceDeviceNFT">
            <summary>
            Related Device NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.EncryptedSettingString">
            <summary>
            Encrypted form of settings as serialized string
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.EncryptedLocationString">
            <summary>
            Encrypted form of the location
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.EncryptedLocationCoordinatesString">
            <summary>
            Encrypted form of location coordinates
            </summary>
        </member>
        <member name="E:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.NewMessage">
            <summary>
            New message arrived event
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.IoTDataDriver">
            <summary>
            IoT Data Driver
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill the data of the NFT
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific data for the NFT
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse origin data of the NFT
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.GetLastData">
            <summary>
            Get last data for this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get NFT metadata.
            </summary>
            <param name="address"></param>
            <param name="key"></param>
            <param name="receiver"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.DecryptSetting(NBitcoin.BitcoinSecret)">
            <summary>
            Decrypt the IoT connection settings. You must provide the BitcoinSecret
            </summary>
            <param name="secret"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.InitCommunication(NBitcoin.BitcoinSecret)">
            <summary>
            Start the communication. If the settings is encrypted you must provide the bitcoin secret
            </summary>
            <param name="secret"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.MarkMessageAsProcessed(System.String)">
            <summary>
            Mark the message as processed. It will add it to the dictionary with new flag Processed instead of ToProcess
            </summary>
            <param name="messageName"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTDeviceNFT.DeInitCommunication">
            <summary>
            Deinitalization of the communication with the IoT API
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.DevicesNFTs.IoTMessageNFT.Decrypt(NBitcoin.BitcoinSecret,System.Boolean)">
            <summary>
            this function will decrypt the NFT if it is possile
            It needs the owner Private Key to create shared password which the combination of the sender public key.
            </summary>
            <param name="secret">Owner Private Key</param>
            <param name="decryptEvenOnSameAddress">Set true when you have preset the partner address manually - for example encryption on same address. </param>
            <returns>true if success</returns>
        </member>
        <member name="P:VEDriversLite.NFT.DogeftInfo.License">
            <summary>
            Here can be described license
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DogeftInfo.Coppies">
            <summary>
            If this is 0 (default) it is unique NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DogeftInfo.AuthorUrl">
            <summary>
            If you want to provide some author personal page
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DogeftInfo.RewardSchemeName">
            <summary>
            Reward scheme for the sale of the NFT. Default is Dogeft standard : 80% to the author, 10% charity, 10% dogeft
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.DogeftInfo.AuthorDogeAddress">
            <summary>
            Author Deposit Doge address where Dogeft will send the reward from sale
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Dto.ReceiversListItem">
            <summary>
            List of the receivers for multiminting.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.ReceiversListItem.Address">
            <summary>
            Address of the receiver
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.ReceiversListItem.UseAsReceiver">
            <summary>
            Use as the receiver during the sending
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.ReceiversListItem.Done">
            <summary>
            Was send to this receiver
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.ReceiversListItem.TxId">
            <summary>
            Transaction hash of the sending
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Dto.MintingTabData">
            <summary>
            Data for the minting tab/page
            It contains common dtos for usuall need of minting page
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.MintingNFTType">
            <summary>
            Type of the NFT which should be minted on the form
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.MenuButonLabel">
            <summary>
            Label of the button in the menu.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.HeaderLabel">
            <summary>
            Second part in header of the page "{AppData.Nick} - {HeaderLabel}"
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.TabPageLocationName">
            <summary>
            Page location name for example for https://basedataplace.com/addnew is "addnew"
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.NFT">
            <summary>
            NFT to mint
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.NFTTemplate">
            <summary>
            Template NFT loaded from network, text or file
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.IsMinting">
            <summary>
            Is minting in process?
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.IsMinted">
            <summary>
            Is minting finished
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.MintingResult">
            <summary>
            Result of the minting.
            In case of false it holds the message, in case of true it holds NFT hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.Addresses">
            <summary>
            Receivers with details about the transaction if it is done
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.MintingTabData.ConsoleOutFromMinting">
            <summary>
            Console output from the minting process
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Dto.NFTCacheDto">
            <summary>
            Class offers way how to store the loaded NFT data for the recovering of the NFT after reload without requesting API
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTCacheDto.LastAccess">
            <summary>
            Last time when the NFT was loaded from the cash
            this helps to remove old not used NFTs from the cache
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTCacheDto.FirstSave">
            <summary>
            indicate when the NFT was saved in the cash first time
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Dto.DataItemType">
            <summary>
            Type of the content
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemType.Image">
            <summary>
            Image file, file .bmp, .jpg, .jpeg, .gif, .png, jfif
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemType.AVMedia">
            <summary>
            Audio or Video file, file .wav, .ogg, .mp3, .mp4, .avi, .mov
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemType.PDF">
            <summary>
            PDF file, file .pdf
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemType.Text">
            <summary>
            Simple text, file .txt
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemType.Markdown">
            <summary>
            Text file with Markdown formating, file .md
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemType.Mermaid">
            <summary>
            Mermaid graph, file .mmd
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemType.HTML">
            <summary>
            HTML file, file .html
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemType.JSON">
            <summary>
            Json file, file .json
            </summary>       
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemType.Model3dSTL">
            <summary>
            3d model in STL, file .stl
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Dto.DataItemStorageType">
            <summary>
            Type of the storage where the data are stored. Usually it is IPFS.
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemStorageType.IPFS">
            <summary>
            IPFS storage
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemStorageType.Url">
            <summary>
            Common url
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Dto.DataItemStorageType.Local">
            <summary>
            Local storage
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Dto.NFTDataItem">
            <summary>
            Item in the NFT gallery. It is usually some image with tags
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTDataItem.Type">
            <summary>
            Type of the item
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTDataItem.Hash">
            <summary>
            Hash of the transaction
            </summary>        
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTDataItem.Storage">
            <summary>
            Type of the storage where the data are stored. Usually it is IPFS.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTDataItem.TagsList">
            <summary>
            Parsed tags from the TagsList
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTDataItem.Data">
            <summary>
            Loaded data as byte array
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTDataItem.IsMain">
            <summary>
            Display flag for UI
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Dto.NFTHash">
            <summary>
            Dto for shorten informations for the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.MainAddress">
            <summary>
            Main address where this NFT is located or it is on the SubAccount address related to this main account
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.SubAccountAddress">
            <summary>
            Sub Account address where this NFT is located
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.TxId">
            <summary>
            whole transaction hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.Index">
            <summary>
            Intex of the utxo
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.Name">
            <summary>
            Name of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.Description">
            <summary>
            Description of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.AuthorDogeAddress">
            <summary>
            Author dogecoin address
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.Image">
            <summary>
            Image in the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.Link">
            <summary>
            Another link in the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.Price">
            <summary>
            Price of the NFT, usually in the Neblio
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.DogePrice">
            <summary>
            Dogecoin price of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.DogeftInfo">
            <summary>
            Dogeft info in the NFT - describe model of sell
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.Type">
            <summary>
            Type of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTHash.ShortHash">
            <summary>
            Shorten hash of the NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Dto.NFTHash.GetShortHash(System.String,System.Int32)">
            <summary>
            Get shorten hash of the NFT
            </summary>
            <param name="txid"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Dto.NFTSoldInfo">
            <summary>
            Info about sold NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTSoldInfo.PaymentTxId">
            <summary>
            Payment transaction hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTSoldInfo.Amount">
            <summary>
            Total amount
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTSoldInfo.Currency">
            <summary>
            Currency
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTSoldInfo.Platform">
            <summary>
            Platform where the NFT was sold
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTSoldInfo.SellAsMultipleCopy">
            <summary>
            Sell as multiple NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTSoldInfo.MaxSupply">
            <summary>
            Maximum supply of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTSoldInfo.OriginalNFTTemplate">
            <summary>
            Original NFT used for mint the copy
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Dto.NFTSoldInfo.IsEmpty">
            <summary>
            Is this dto empty?
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.ClassOfNFTEvent">
            <summary>
            Class of the Event NFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.ClassOfNFTEvent.PersonalEvent">
            <summary>
            Personal event
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.ClassOfNFTEvent.OnlineMeeting">
            <summary>
            Online meeting, webinar, etc.
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.ClassOfNFTEvent.CorporateMeeting">
            <summary>
            Business or company meetings
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.ClassOfNFTEvent.Festival">
            <summary>
            Common festival
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.ClassOfNFTEvent.Concert">
            <summary>
            Common concert
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.ClassOfNFTEvent.Birthday">
            <summary>
            Birthday parties events
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.ClassOfNFTEvent.PlaneFlight">
            <summary>
            Plane flight event
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.EventNFT">
            <summary>
            Event NFT
            Describing Event for the creating of the NFT Tickets
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.EventNFT.#ctor(System.String)">
            <summary>
            Create empty event
            </summary>
            <param name="utxo"></param>
        </member>
        <member name="M:VEDriversLite.NFT.EventNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.EventNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.EventNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.EventNFT.GetLastData">
            <summary>
            Get last data of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.EventNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.ImageNFT">
            <summary>
            Basic Image NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.ImageNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.ImageNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.ImageNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.ImageNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.ImageNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.Dto.DetectorDataDto">
            <summary>
            Parameters of the Xray detector
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.DetectorDataDto.W">
            <summary>
            Number of columnts - width
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.DetectorDataDto.H">
            <summary>
            Number of rows - height
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.DetectorDataDto.Bits">
            <summary>
            Bit depth of image data in one pixel
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.DetectorDataDto.Sc">
            <summary>
            Type of the scintilator
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.DetectorDataDto.Pw">
            <summary>
            Detection element width in micro meters
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.DetectorDataDto.Ph">
            <summary>
            Detection element height in micro meters
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.Dto.DetectorDataDto.IsDefault">
            <summary>
            Returns true if the all values inside class are in default values
            </summary>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.Dto.SourceParametersDto">
            <summary>
            Parameters of the Xray source
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.SourceParametersDto.AT">
            <summary>
            X-ray tube anode type.
            Most of the Xray tubes uses Reflexive or Transmision
            R - Reflexive
            T - Transmision
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.SourceParametersDto.TM">
            <summary>
            Material of the anode target. Usually it is made from Wolfram
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.SourceParametersDto.FW">
            <summary>
            Focal spot width in micro meters
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.SourceParametersDto.FH">
            <summary>
            Focal spot height in micro meters
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.SourceParametersDto.FA">
            <summary>
            Focal spot angle if Reflexive
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.SourceParametersDto.MinV">
            <summary>
            Minimum voltage on anode
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.SourceParametersDto.MaxV">
            <summary>
            Maximum voltage on anode
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.Dto.SourceParametersDto.IsDefault">
            <summary>
            Returns true if the all values inside class are in default values
            </summary>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.Dto.AxisDto">
            <summary>
            Parameters of the axis of positionning system
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.AxisDto.Ax">
            <summary>
            Axis name: X, Y, Z, R
            R is rotation stand for the object
            Robotics Joints - R1, R2, R3, R4, R5, R6
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.AxisDto.Ac">
            <summary>
            Accuracy of step
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.AxisDto.L">
            <summary>
            Length of whole axis
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.AxisDto.Stp">
            <summary>
            Number of steps per whole axis
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.AxisDto.Start">
            <summary>
            Start of the used part of the axis - virtual zero point
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.AxisDto.End">
            <summary>
            End of the used part of the axis - virtual end point
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.Dto.PositionerParametersDto">
            <summary>
            Positioner parameters, including axis parameters
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.PositionerParametersDto.Axes">
            <summary>
            Information about the all axes in the positioner
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.Dto.PositionerParametersDto.IsDefault">
            <summary>
            Returns true if the all values inside class are in default values
            </summary>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto">
            <summary>
            Scanned object position in the scene
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto.X">
            <summary>
            Object Position X
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto.Y">
            <summary>
            Object Position Y
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto.Z">
            <summary>
            Object Position Z
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto.R1">
            <summary>
            Object Rotation R1
            It is rotation in XY plane
            Rotation is in degrees
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto.R2">
            <summary>
            Object Rotation R2
            It is rotation in XZ plane
            Rotation is in degrees
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto.R3">
            <summary>
            Object Rotation R3
            It is rotation in ZY plane
            Rotation is in degrees
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto.Dsd">
            <summary>
            Distance between Source Focal spot and Detector
            Distance is in milimeters
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto.Dod">
            <summary>
            Distance between Object rotation Axis XY center and Detector
            Distance is in milimeters
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.Dto.ObjectPositionDto.IsDefault">
            <summary>
            Returns true if the all values inside class are in default values
            </summary>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.Dto.XrayExposureParameters">
            <summary>
            Exposure parameters of the captured image
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.XrayExposureParameters.Voltage">
            <summary>
            Anode voltage on the X-ray tube in the kilo Volts - kV
            Usuall range is between 20 - 150 kV. 
            For casting or welding it can be even 225kV, 450kV or more.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.XrayExposureParameters.Current">
            <summary>
            Current through the X-ray tube in the micro Ampers - uA
            Usuall range starts from 50uA and can go up to 1-10 mili Ampers (mA) or more for casting/welding
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.XrayExposureParameters.Filters">
            <summary>
            List of the primary filters. These filters are real materials placed directly on the outpu window of the Xray tube
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.XrayExposureParameters.ExposureTime">
            <summary>
            Exposure time in ms - how long X-ray goes to the detector per one captured image/frame
            Usuall range starts from 10ms and can goes up to 10 seconds. More in special cases or casting/welding.
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.Dto.XrayExposureParameters.IsDefault">
            <summary>
            Returns true if the all values inside class are in default values
            </summary>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.Dto.XrayTubeAnodeType">
            <summary>
            Type of the Xray tube anode.
            Most of the Xray tubes uses Reflexive or Transmision
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Imaging.Xray.Dto.XrayTubeAnodeType.Reflexive">
            <summary>
            Reflexive anode
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Imaging.Xray.Dto.XrayTubeAnodeType.Transmision">
            <summary>
            Transmision anode
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Imaging.Xray.Dto.XrayTubeAnodeType.ReflexiveRotary">
            <summary>
            Rotary anode with classic reflexive target
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Imaging.Xray.Dto.XrayTubeAnodeType.Straton">
            <summary>
            Rotary anode type Straton 
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.Dto.XrayPrimaryFiltrationMaterials">
            <summary>
            Materials list for primary filtration
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Imaging.Xray.Dto.XrayPrimaryFiltrationMaterials.Al">
            <summary>
            Aluminium
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Imaging.Xray.Dto.XrayPrimaryFiltrationMaterials.Cu">
            <summary>
            Cuprum
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.Imaging.Xray.Dto.XrayPrimaryFiltrationMaterials.Pb">
            <summary>
            Lead
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.Dto.XrayPrimaryFilter">
            <summary>
            Primary filter on the xray tube
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.XrayPrimaryFilter.Material">
            <summary>
            Material of the primary filter
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.Dto.XrayPrimaryFilter.Thickness">
            <summary>
            Thickness of the primary filter
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT">
            <summary>
            Xray image NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.#ctor">
            <summary>
            Create empty Xray Image NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.#ctor(System.String)">
            <summary>
            Create empty Xray Image NFT
            <paramref name="utxo">Input utxo of this NFT</paramref>
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.XrayParams">
            <summary>
            Xray exposure parameters
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.IsOriginal">
            <summary>
            This flag Indicates if the image stored in link are original or are already processed with some filters, etc.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.IsRaw">
            <summary>
            This flag Indicates if the image data stored on IPFS are raw. 
            In that case it needs the width, height and bitdepts/format to be able use/display them
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.IsAveraged">
            <summary>
            If this is on, the result image is averaged from multiple images
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.CountOfFrames">
            <summary>
            If the image is averaged from multiple frames this number tells how many frames was used
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.DetectorParameters">
            <summary>
            Data about the detector. 
            It is necessary to fill if the image data are raw
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.ObjectPosition">
            <summary>
            Object Position parameters
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.XrayDeviceNFTHash">
            <summary>
            Xray device NFT Hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.XrayDeviceNFT">
            <summary>
            Loaded Xray Device NFT 
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.GetLastData">
            <summary>
            Get last data of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayImageNFT.LoadXrayNFT">
            <summary>
            Load Xray device NFT
            </summary>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Imaging.Xray.XrayNFT">
            <summary>
            Xray device NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayNFT.#ctor">
            <summary>
            Create empty NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayNFT.#ctor(System.String)">
            <summary>
            Create empty NFT with preload hash
            </summary>
            <param name="utxo"></param>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayNFT.DeviceName">
            <summary>
            Commercial Xray Device Product Type
            Leave empty if unknown or custom
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayNFT.DetectorName">
            <summary>
            Commercial Detector Produt Type
            Leave empty if unknown or custom.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayNFT.SourceName">
            <summary>
            Commercial X Ray source Product Type
            Leave empty if unknown or custom.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayNFT.PositionerName">
            <summary>
            Commercial Positioner Product Type
            This can be also robot type if the robot is used for manipulation
            Leave empty if unknown or custom.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayNFT.DetectorParameters">
            <summary>
            Data about the detector. 
            It is necessary to fill if the standart type of the detector is not provided.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayNFT.SourceParameters">
            <summary>
            Xray source parameters.
            It is recommended to fill them
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Imaging.Xray.XrayNFT.PositionerParameters">
            <summary>
            Positioner parameters. Informations about the axes
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayNFT.GetLastData">
            <summary>
            Get last data of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.Imaging.Xray.XrayNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.NFTTypes">
            <summary>
            Definition of the NFT types. 
            If you want to add your own NFT you should start here
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Image">
            <summary>
            Basic Image NFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Post">
            <summary>
            Basic Post NFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Profile">
            <summary>
            Profile NFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Music">
            <summary>
            Music NFT - can hold also video
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.YouTube">
            <summary>
            Youtube specific NFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Spotify">
            <summary>
            Spotify specific NFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Payment">
            <summary>
            Payment NFT. It is used for buy another NFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Message">
            <summary>
            NFT message
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Ticket">
            <summary>
            Ticket for some NFT Event
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Event">
            <summary>
            NFT Event, base for the creating NFT Tickets
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Receipt">
            <summary>
            Receipt after sold NFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Order">
            <summary>
            NFT Order, base for NFT Invoice
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Invoice">
            <summary>
            NFT Invoice, based on the previous NFT Order
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Product">
            <summary>
            NFT Product is base for the Order and Invoice. 
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.CoruzantArticle">
            <summary>
            Coruzant specific article
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.CoruzantPremiumArticle">
            <summary>
            Coruzant specific premium article
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.CoruzantPodcast">
            <summary>
            Coruzant specific podcast
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.CoruzantPremiumPodcast">
            <summary>
            Coruzant specific premium podcast
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.CoruzantProfile">
            <summary>
            Coruzant profile
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Device">
            <summary>
            NFT Device, base for NFT IoT Device
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.IoTDevice">
            <summary>
            NFT IoT Device, based on the NFT Device. It can acquire the data from the IoTDataDrivers
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Protocol">
            <summary>
            NFT Protocol. Description of the communication for Device and IoTDevice
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.HWSrc">
            <summary>
            HW source of the NFT Device
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.FWSrc">
            <summary>
            FW source of the NFT Device
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.SWSrc">
            <summary>
            SW source of the NFT Device
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.MechSrc">
            <summary>
            Mechanical source of the NFT Device
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.IoTMessage">
            <summary>
            IoT specific message. usually carry JSON object in Description or Text properties
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.Xray">
            <summary>
            Xray device
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTTypes.XrayImage">
            <summary>
            Xray Image
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.INFT">
            <summary>
            Main NFT interface
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.TypeText">
            <summary>
            Text form of the NFT type like "NFT Image" or "NFT Post"
            The parsing is in the Common NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Type">
            <summary>
            NFT Type by enum of NFTTypes
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Name">
            <summary>
            Name of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Author">
            <summary>
            Author of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Description">
            <summary>
            Description of the NFT - for longer text please use the "Text" property
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Text">
            <summary>
            Text of the NFT - prepared for the longer texts
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Link">
            <summary>
            Link to some webiste in the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.IconLink">
            <summary>
            Link to the icon of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.ImageLink">
            <summary>
            Link to the image in the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.ImageData">
            <summary>
            Loaded Image data as byte array
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Preview">
            <summary>
            Preview data of image or music
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.PreviewData">
            <summary>
            Data of the preview file
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Tags">
            <summary>
            List of the tags separated by space
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.TagsList">
            <summary>
            Parsed tag list. It is parsed in Common NFT class
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.DataItems">
            <summary>
            More items in the NFT, for example Image gallery with more images than one
            Probably future replacement of the "ImageLink" property
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Utxo">
            <summary>
            NFT Utxo hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.UtxoIndex">
            <summary>
            NFT Utxo Index
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.ShortHash">
            <summary>
            Shorten hash including index number
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.NFTOriginTxId">
            <summary>
            NFT Origin transaction hash - minting transaction in the case of original NFTs (Image, Music, Ticket)
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.SourceTxId">
            <summary>
            Source tx where the input for the NFT Minting was taken
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.TokenId">
            <summary>
            Id of the token on what the NFT is created
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Price">
            <summary>
            Price of the NFT in the Neblio
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.PriceActive">
            <summary>
            PriceActive is setted automatically when the price is setted up
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.DogePrice">
            <summary>
            Price of the NFT in the Dogecoin
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.DogePriceActive">
            <summary>
            DogePriceActive is setted automatically when the price is setted up
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.DogeAddress">
            <summary>
            Related Doge Address to this NFT. If it is created by VENFT App it is filled automatically during the minting request
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.SellJustCopy">
            <summary>
            Set that this NFT will be sold as just in coppies minted for the buyer
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.DogeftInfo">
            <summary>
            Info for publishing NFT to the Dogeft
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.IsLoaded">
            <summary>
            If the NFT is fully loaded this flag is set
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.IsInThePayments">
            <summary>
            If the NFT is alredy saw in the payment this is set
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.SoldInfo">
            <summary>
            If the NFT is sold this will be filled
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.Time">
            <summary>
            DateTime stamp taken from the blockchain trnsaction
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.History">
            <summary>
            History of this NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.INFT.TxDetails">
            <summary>
            The transaction info details
            </summary>
        </member>
        <member name="E:VEDriversLite.NFT.INFT.TxDataRefreshed">
            <summary>
            This event is fired when the transaction info is refreshed
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.IsSpendable">
            <summary>
            Return info if the transaction is spendable
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.FillCommon(VEDriversLite.NFT.INFT)">
            <summary>
            Fill common properties for the NFT
            </summary>
            <param name="nft"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill common and specific properties of the NFT
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.LoadLastData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Load last data of the NFT.
            It means that it will take just the last data and not tracking the origin for the orign data
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse the origin data of the NFT.
            It will track the NFT to its origin and use the data from the origin
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.ParseSoldInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse info about the sellfrom the metadata of the NFT
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.ParseCommon(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse Common Properties from Metadata
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.ParsePrice(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse price from the metadata of the NFT
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific information related to the specific kind of the NFT. 
            This function must be overwritte in specific NFT class
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.ParseDogeftInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse dogeft info from the metadata
            </summary>
            <param name="meta"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.ClearSoldInfo">
            <summary>
            Clear the object with SoldInfo of NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.LoadHistory">
            <summary>
            Load NFT history.
            It will load fully all history steps of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.ClearPrices">
            <summary>
            Clear all the prices inside of the NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.ParseTags">
            <summary>
            Parse tags to tag list
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.StopRefreshingData">
            <summary>
            Stop the auto refreshin of the tx info data
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.StartRefreshingTxData(System.Int32)">
            <summary>
            Start auto refreshing of the tx info data
            </summary>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Retrive the Metadata of the actual NFT. 
            It will take the correct properties and translate them to the dictionary which can be add to the token transaction metdata
            If the NFT contains encrypted metadata with use of Shared Secret (EDCH) like NFT Message you must provide the parameters if you need to do encryption
            </summary>
            <param name="address">Address of the sender of the NFT</param>
            <param name="key">Private key of the sender of the NFT</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.GetCommonMetadata">
            <summary>
            Get Common Metadata of the Actual NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.DownloadPreviewData">
            <summary>
            Download preview data if there are some
            </summary>
            <returns>true if success</returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.DownloadImageData">
            <summary>
            Download Image data if there are some
            </summary>
            <returns>true if success</returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.DecryptImageData(NBitcoin.BitcoinSecret,System.String,System.String,System.String)">
            <summary>
            This function will download the data from the IPFS then decrypt the encrypted file container with use of shared secret.
            Then the image is saved in ImageData as bytes.
            </summary>
            <param name="secret">NFT Owner Private Key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.INFT.DecryptProperty(System.String,NBitcoin.BitcoinSecret,System.String,System.String,System.String)">
            <summary>
            Decrypt the specific property with use of shared secret
            </summary>
            <param name="prop">Property content</param>
            <param name="secret">NFT Owner Private Key</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.InvoiceItem">
            <summary>
            Item for Invoice or Order NFTs
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceItem.ItemUtxo">
            <summary>
            Item Utxo hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceItem.ItemUtxoIndex">
            <summary>
            Item Utxo index
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceItem.ItemPrice">
            <summary>
            Item price - one line of invoice
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceItem.ItemCount">
            <summary>
            Count of the items - one line of invoice
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceItem.InvoiceProductNFT">
            <summary>
            Loaded Product NFT
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.InvoiceNFT">
            <summary>
            Invoice NFT is based on NFT Order and NFT Product
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.InvoiceNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.InvoiceItems">
            <summary>
            List of the invoice items - ivoice lines
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.SellerProfileNFT">
            <summary>
            Seller profile NFT hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.BuyerProfileNFT">
            <summary>
            Buyer profile NFT hahs
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.OriginalPaymentTxId">
            <summary>
            Hash of the original payment
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.OrderTxId">
            <summary>
            Hash of the Order NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.FileLink">
            <summary>
            Related file link - for example some attachenment on IPFS
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.TotalPrice">
            <summary>
            Total price of the invoice
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.InvoiceNFT.AlreadyPaid">
            <summary>
            Flag for already paid invoices
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.ExposeDate">
            <summary>
            Date when invoice has been created
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.MaxCountOfDaysFromExposeToPayment">
            <summary>
            Maximum pay term - how long can the buyer pay the invoice
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.InvoiceNFT.MaxCountOfDaysAfterPaymentDate">
            <summary>
            Maximum count of days after the peyment should be paid
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.InvoiceNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.InvoiceNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.InvoiceNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.InvoiceNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.MessageNFT">
            <summary>
            NFT message allows to send encrypted messages between two peers
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.MessageNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.MessageNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="P:VEDriversLite.NFT.MessageNFT.Encrypt">
            <summary>
            Encrypt the message before the send
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.MessageNFT.Decrypted">
            <summary>
            Has been message already decrypted?
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.MessageNFT.Partner">
            <summary>
            Communication partner
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.MessageNFT.SharedKey">
            <summary>
            If the shared key was calculated, take it from here
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.MessageNFT.IsReceivedMessage">
            <summary>
            Was this message received or sent
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.MessageNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.MessageNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.MessageNFT.GetLastData">
            <summary>
            Get last data of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.MessageNFT.GetPartner">
            <summary>
            Load communication partner info
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.MessageNFT.GetReceiver">
            <summary>
            Get receiver of this message
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.MessageNFT.Decrypt(NBitcoin.BitcoinSecret,System.Boolean)">
            <summary>
            this function will decrypt the NFT if it is possile
            It needs the owner Private Key to create shared password which the combination of the sender public key.
            </summary>
            <param name="secret">Owner Private Key</param>
            <param name="decryptEvenOnSameAddress">Set true when you have preset the partner address manually - for example encryption on same address. </param>
            <returns>true if success</returns>
        </member>
        <member name="M:VEDriversLite.NFT.MessageNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.MusicNFT">
            <summary>
            Basic music NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.MusicNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.MusicNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.MusicNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.MusicNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.MusicNFT.GetLastData">
            <summary>
            Get last data of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.MusicNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.NFTDataContext">
            <summary>
            NFT shared data context
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.NFTDataContext.Tags">
            <summary>
            All loaded apps in instance
            </summary>     
        </member>
        <member name="T:VEDriversLite.NFT.NFTFactory">
            <summary>
            Main factory for creating the NFTs from hash of the transaction
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.NFTFactory.ParseNFTType(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse the type of the NFT from the transaction metadata
            </summary>
            <param name="metadata"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:VEDriversLite.NFT.NFTFactory.GetNFT(System.String,System.String,System.Int32,System.Double,System.Boolean,System.Boolean,VEDriversLite.NFT.NFTTypes,System.Boolean,VEDriversLite.NFT.NFTTypes,System.String,VEDriversLite.NeblioAPI.GetTransactionInfoResponse)">
            <summary>
            Create and load the NFT from the transaction hash
            </summary>
            <param name="tokenId">Optional. If you know please provide to speed up the loading.</param>
            <param name="utxo">NFT transaction hash</param>
            <param name="utxoindex">Index of the NFT output. This is important for NFTs from multimint.</param>
            <param name="time">already parsed time</param>
            <param name="wait">await load - obsolete</param>
            <param name="loadJustType">load just specific type of NFT</param>
            <param name="justType">specify the type of the NFT which can be load - you must turn on justType flag</param>
            <param name="skipTheType">skip some type of NFT</param>
            <param name="skipType">specify the type of NFT which should be skipped - you must turn on skipTheType flag</param>
            <param name="address">Specify address of owner</param>
            <param name="txinfo">if you have loaded txinfo provide it to speed up the loading</param>
            <returns>INFT compatible object</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTFactory.CloneNFT(VEDriversLite.NFT.INFT,System.Boolean,VEDriversLite.NFT.NFTTypes)">
            <summary>
            Clone the NFT
            </summary>
            <param name="NFT">input NFT to clone</param>
            <param name="asType">Force the type of the output NFT</param>
            <param name="type">specify the type - you must turn on asType flag</param>
            <returns>INFT compatible object cloned from source</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTFactory.GetNFTFromCacheMetadata(System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.Int32,VEDriversLite.NeblioAPI.GetTransactionInfoResponse,System.Boolean,VEDriversLite.NFT.NFTTypes)">
            <summary>
            Load the NFT based on the data from the cache
            </summary>
            <param name="metadata">Metadata from cache of NFTs</param>
            <param name="utxo">Utxo of the NFT</param>
            <param name="utxoindex">Utxo Index of the NFT</param>
            <param name="txinfo">preloaded txinfo</param>
            <param name="asType">Force the output type</param>
            <param name="type">Specify the output type - you must set asType flag</param>
            <returns>INFT compatible object</returns>
        </member>
        <member name="T:VEDriversLite.NFT.LoadingImageStages">
            <summary>
            Enum for loading of image/music/data stage
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.LoadingImageStages.NotStarted">
            <summary>
            Loading image stage - not started
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.LoadingImageStages.Loading">
            <summary>
            Loading image stage - loading in progress
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.LoadingImageStages.Loaded">
            <summary>
            Loading image stage - Loaded successfully
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.LoadingImageStages.Failed">
            <summary>
            Loading image stage - load failed
            </summary>        
        </member>
        <member name="T:VEDriversLite.NFT.LoadNFTOriginDataDto">
            <summary>
            Dto for search of the Origin of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.LoadNFTOriginDataDto.Utxo">
            <summary>
            Actual Utxo
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.LoadNFTOriginDataDto.SourceTxId">
            <summary>
            Source Utxo
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.LoadNFTOriginDataDto.NFTOriginTxId">
            <summary>
            Origin of the NFT Utxo if known
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.LoadNFTOriginDataDto.Used">
            <summary>
            Tag which is used to identify the NFT is "used" stage - for example ticket
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.LoadNFTOriginDataDto.NFTMetadata">
            <summary>
            Metadata from the NFT history moment
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.IPFSResponse">
            <summary>
            Dto for the parse response of the IPFS server
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.IPFSResponse.Name">
            <summary>
            Name of the File
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.IPFSResponse.Hash">
            <summary>
            Hash of the file
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.IPFSResponse.Size">
            <summary>
            Size of the file
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.NFTHelpers">
            <summary>
            Helper static class for the NFT Operations and especially preparation of the NFT data
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.AllowedTokens">
            <summary>
            List of the allowed tokens. If you want to use your own tokens you can add them here
            The hash is the Token hash of the NTP1 token created on the Neblio network
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.InfuraKey">
            <summary>
            Infura Key for the access to the IPFS API
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.InfuraSecret">
            <summary>
            Infura Secret for the access to the IPFS API
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.InfuraAPIURL">
            <summary>
            Infura Url for the access to the IPFS API
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.TokenId">
            <summary>
            Main default tokens in VEFramework - VENFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.BDPTokenId">
            <summary>
            Main default Data storage tokens in VEFramework - BDP
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.WDOGETokenId">
            <summary>
            WDOGE token
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.TokenSymbol">
            <summary>
            Main default tokens symbol in VEFramework - VENFT
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.ipfs">
            <summary>
            IPFS Client
            </summary>
        </member>
        <member name="F:VEDriversLite.NFT.NFTHelpers.ipfsInfura">
            <summary>
            IPFS Client - special for Infura
            </summary>
        </member>
        <member name="E:VEDriversLite.NFT.NFTHelpers.NewEventInfo">
            <summary>
            New event happened - IEventInfo type of the message
            </summary>
        </member>
        <member name="E:VEDriversLite.NFT.NFTHelpers.ProfileNFTFound">
            <summary>
            This event is called profile nft is found in the list of nfts
            </summary>
        </member>
        <member name="E:VEDriversLite.NFT.NFTHelpers.NFTLoadingStateChanged">
            <summary>
            This event is called profile nft is found in the list of nfts
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.InitHandlers">
            <summary>
            Init handler to receive event info messages from Neblio Transaction Helpers class
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.DeInitHandlers">
            <summary>
            Deinit handler to receive event info messages from Neblio Transaction Helpers class
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.IsBuyableNFT(VEDriversLite.NFT.NFTTypes)">
            <summary>
            Return true if the type is allowed to buy and sell
            Actually are supported Image, Music, Post, Ticket NFTs.
            </summary>
            <param name="nftType"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.NeblioTransactionHelpers_NewEventInfo(System.Object,VEDriversLite.Events.IEventInfo)">
            <summary>
            Process new received info from Neblio Transaction Helpers class. Now just resend higher
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetHashFromIPFSLink(System.String)">
            <summary>
            Remove the server address from link and return just IPFS Hash
            </summary>
            <param name="link"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetIPFSLinkFromHash(System.String)">
            <summary>
            Get full IPFS link from the hash
            </summary>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.UploadImage(System.IO.Stream,System.String,System.String)">
            <summary>
            Obsolete function - just example how to redirect upload through different server
            </summary>
            <param name="stream"></param>
            <param name="fileName"></param>
            <param name="fileContentType"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.LoadConnectionInfo(System.String,System.String,System.String)">
            <summary>
            Load connection info to the internal variables of this class
            </summary>
            <param name="ipfsKey"></param>
            <param name="ipfsSecret"></param>
            <param name="apiurl"></param>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.CreateIpfsClient(System.String,System.String,System.String)">
            <summary>
            Create IPFS client with authentication
            </summary>
            <param name="IpfsHostUrl"></param>
            <param name="IpfsHostUserName"></param>
            <param name="IpfsHostPassword"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.UploadInfura(System.IO.Stream,System.String,System.String)">
            <summary>
            Upload file to the Infura IPFS
            </summary>
            <param name="stream"></param>
            <param name="fileName"></param>
            <param name="fileContentType"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.IPFSDownloadFromInfuraAsync(System.String)">
            <summary>
            Download file from IPFS Infura with use of credentials
            </summary>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.IPFSDownloadFromPublicAsync(System.String)">
            <summary>
            Download file from IPFS public
            </summary>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.InitNFTHelpers">
            <summary>
            Add allowed tokens during the initialization
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.LoadNFTOriginData(System.String,System.Boolean)">
            <summary>
            This function will iterate through inputs of tx from the point of the utxo to find tx where this 1 token was splited from some lot.
            Metadata from this founded tx is returned for load to NFT carrier.
            This method is now used for "original" NFTs. It is for example Image and Music. 
            </summary>
            <param name="utxo"></param>
            <param name="checkIfUsed">if you are checking the NFT ticket you should set this flag</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.LoadLastData(System.String)">
            <summary>
            This will load just last transaction metadata if it is NFT metadata. 
            This function will not iterate to start/origin. It is used for example in Post
            </summary>
            <param name="utxo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.CheckIfContainsNFTData(System.String)">
            <summary>
            this function will obtain tx metadata and check if it contains flag NFT true
            </summary>
            <param name="utxo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.CheckIfMintTx(System.String)">
            <summary>
            This function will check if the transaction is mint transaction. it means if the input to this tx was lot of the tokens.
            This kind of transaction means origin for the NFTs.
            </summary>
            <param name="utxo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.FindProfileOfAddress(System.String,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            this function will search the utxos, get all nfts utxos (if utxos list is not loaded) and return last profile nft which is founded on the address.
            </summary>
            <param name="address"></param>
            <param name="utxos">leave null if you need to obtain new utxos nft list</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.FindEventOnTheAddress(System.String,System.String,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            this function will search the utxos, get all nfts utxos (if utxos list is not loaded) and return last profile nft which is founded on the address.
            </summary>
            <param name="address"></param>
            <param name="nftOriginTxId"></param>
            <param name="utxos">leave null if you need to obtain new utxos nft list</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.LoadAddressNFTsWithProfile(System.String)">
            <summary>
            This function will load NFTs and during it find the profile NFT
            </summary>
            <param name="address"></param>
            <returns>profile NFT and list of all NFTs</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.LoadAddressNFTs(System.String,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Collections.Generic.ICollection{VEDriversLite.NFT.INFT},System.Boolean,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            This function will find all NFTs and load them to the carriers. 
            If you already have list of utxos and NFTs you can provide it and it will load just the changes.
            </summary>
            <param name="address">Address with this NFTs</param>
            <param name="inutxos">Input Utxos collection</param>
            <param name="innfts">Input NFTs collection</param>
            <param name="fireProfileEvent">If you find profile, fire the event</param>
            <param name="maxLoadedItems">Limit number of loaded items</param>
            <param name="withoutMessages">Do not load messages</param>
            <param name="justMessages">Load just messages</param>
            <param name="justPayments">Load just Payments</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.LoadNFTsHistory(System.String)">
            <summary>
            Returns list of NFTs with the data of the point of this history of some NFT.
            </summary>
            <param name="utxo"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.LoadAddressNFTMessages(System.String,System.String,System.Collections.Generic.ICollection{VEDriversLite.NFT.INFT})">
            <summary>
            Load just the Messages on the address - between the addresses
            </summary>
            <param name="aliceAddress"></param>
            <param name="bobAddress"></param>
            <param name="innfts"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetMintNFTData(System.String,VEDriversLite.Security.EncryptionKey,VEDriversLite.NFT.INFT,System.String)">
            <summary>
            This function will new NFTs. 
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="NFT">Input NFT object with data to save to metadata</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <param name="tutxos">List of spendable token utxos if you have it loaded.</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns>New Tx Id Hash</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetMessageNFTTransaction(System.String,System.String,VEDriversLite.Security.EncryptionKey,VEDriversLite.NFT.INFT,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},NBitcoin.BitcoinSecret,System.String)">
            <summary>
            This function will new Post NFT.
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="NFT">Input NFT object with data to save to metadata</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <param name="tutxos">List of spendable token utxos if you have it loaded.</param>
            <param name="rewriteAuthor">You can rewrite author and use the Profile NFT hash,etc.</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns>New Tx Id Hash</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetIoTMessageNFTTransaction(System.String,System.String,VEDriversLite.Security.EncryptionKey,VEDriversLite.NFT.INFT,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos},System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            This function will new Post NFT.
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="NFT">Input NFT object with data to save to metadata</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <param name="tutxos">List of spendable token utxos if you have it loaded.</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns>New Tx Id Hash</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetMintMultiNFTData(System.String,VEDriversLite.NFT.INFT,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            This function will new Post NFTs as multimint. 
            It means in one transaction it will create multiple 1 tokens outputs which are NFTs with same origin metadata.
            </summary>
            <param name="address">sender address</param>
            <param name="coppies">number of copies. one NFT is minted even 0 coppies is input</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="NFT">Input NFT object with data to save to metadata</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <param name="tutxos">List of spendable token utxos if you have it loaded.</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns>New Tx Id Hash</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetChangeNFTTxData(System.String,VEDriversLite.NFT.INFT)">
            <summary>
            This function will change NFT data.
            In NFT image and music it will be not relevant because it will always search for origin data even if you will rewrite it.
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="nft">Input NFT object with data to save to metadata. Must contain Utxo hash</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <returns>New Tx Id Hash</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetTxDataForOrderedNFT(System.String,VEDriversLite.NFT.PaymentNFT,VEDriversLite.NFT.INFT)">
            <summary>
            This function will take some NFT which was matched with some payment, coppy data and create complete payment, which will send NFT to new owner.
            During this the payment NFT token is send back to project address
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="payment">Payment NFT of received payment</param>
            <param name="NFT">NFT for sale</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetTokenTxDataCopy(System.String,VEDriversLite.NFT.PaymentNFT,VEDriversLite.NFT.INFT)">
            <summary>
            This function will take some NFT which was matched with some payment as copy, coppy data and create complete payment, which will send NFT to new owner.
            During this the payment NFT token is send back to project address
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="payment">Payment NFT of received payment</param>
            <param name="NFT">NFT for sale</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetTxDataForDestroyNFTs(System.String,System.Collections.Generic.ICollection{VEDriversLite.NFT.INFT},System.String)">
            <summary>
            This function will destroy selected NFTs
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <param name="nfts">Input NFTs to destroy</param>
            <param name="mintingUtxo">Minting input Utxo if known</param>
            <param name="receiver">Receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetNFTPaymentData(System.String,System.String,VEDriversLite.NFT.INFT,System.Collections.Generic.ICollection{VEDriversLite.NeblioAPI.Utxos})">
            <summary>
            This function will send payment for some NFT.
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="receiver">Receiver of the NFT</param>
            <param name="nft">Input NFT object with data to save to metadata. It is NFT what you are buying.</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <returns>New Tx Id Hash</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetTxDataForReturnNFTPayment(System.String,VEDriversLite.NFT.PaymentNFT)">
            <summary>
            This function will return payment to the original sender.
            </summary>
            <param name="address">sender address</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="nft">Input PaymentNFT.</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <returns>New Tx Id Hash</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetNFTTxData(System.String,System.String,VEDriversLite.Security.EncryptionKey,VEDriversLite.NFT.INFT,System.Boolean,System.Double,System.Boolean,System.Double)">
            <summary>
            This function will send NFT. It can be also used for write the price of the NFT.
            </summary>
            <param name="address">adress of sender</param>
            <param name="receiver">address of receiver</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="NFT">Input NFT object with data to save to metadata. It is NFT what you are sending.</param>
            <param name="priceWrite">Set this if you just want to set price of the NFT. means resend to yourself</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <param name="price">Price must be higher than 0.0002 Neblio</param>
            <param name="withDogePrice">Set if Doge Price should be written</param>
            <param name="dogeprice">Set doge price, min 0.1</param>
            <returns>New Tx Id hash</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetTxDataForNFTTicket(System.String,VEDriversLite.NFT.INFT)">
            <summary>
            This function will write Used flag to the NFT Ticket
            </summary>
            <param name="address">adress of sender</param>
            <param name="ekey">Encryption Key object of the address</param>
            <param name="NFT">Input NFT object with data to save to metadata. It is NFT what you are sending.</param>
            <param name="nutxos">List of spendable neblio utxos if you have it loaded.</param>
            <returns>New Tx Id hash</returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.FindProfileNFT(System.Collections.Generic.ICollection{VEDriversLite.NFT.INFT})">
            <summary>
            This function will return first profile NFT in NFTs list.
            </summary>
            <param name="nfts"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetPubKeyFromProfileNFTTx(System.String)">
            <summary>
            This function will find profile on address if exists and parse address public key (NBitcoin class) from it.
            Usefull for encryption
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetPubKeyFromLastFoundTx(System.String)">
            <summary>
            This function will find last send transaction by some address and parse public key (NBitcoin class) from it.
            Usefull for encryption.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.NFTHelpers.GetNFTWithOwner(System.String)">
            <summary>
            This function will load the NFT based by Tx Id hash and find the owner of the NFT
            </summary>
            <param name="txid"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.OrderNFT">
            <summary>
            Order NFT is base for Invoice NFT and it needs to load some NFT Products
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.OrderNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.InvoiceItems">
            <summary>
            List of the invoice items - ivoice lines
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.SellerProfileNFT">
            <summary>
            Seller profile NFT hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.BuyerProfileNFT">
            <summary>
            Buyer profile NFT hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.OriginalPaymentTxId">
            <summary>
            Hash of the original payment
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.FileLink">
            <summary>
            Related file link - for example some attachenment on IPFS
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.TotalPrice">
            <summary>
            Total price of the invoice
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.ApprovedByProfile">
            <summary>
            Hash of the profile who approved the order
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.ApprovedNote">
            <summary>
            Note for the order approval
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.Aprooved">
            <summary>
            Was the order approved?
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.AlreadyPaid">
            <summary>
            Has been the order already paid?
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.ExposeDate">
            <summary>
            Date when invoice has been created
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.MaxCountOfDaysFromExposeToPayment">
            <summary>
            Maximum pay term - how long can the buyer pay the invoice
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.OrderNFT.MaxCountOfDaysAfterPaymentDate">
            <summary>
            Maximum count of days after the peyment should be paid
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.OrderNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.OrderNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.OrderNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.OrderNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.OrderNFT.AddInvoiceItem(System.String,System.Int32,System.Double,System.Int32)">
            <summary>
            Add new invoice item to this NFT Invoice
            </summary>
            <param name="utxo">for example Product NFT hash</param>
            <param name="index"></param>
            <param name="price"></param>
            <param name="amount"></param>
        </member>
        <member name="T:VEDriversLite.NFT.PaymentNFT">
            <summary>
            Payment NFT is used for buying NFTs
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.PaymentNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.PaymentNFT.NFTUtxoTxId">
            <summary>
            original NFT hash which was sold
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.PaymentNFT.NFTUtxoIndex">
            <summary>
            original NFT index which was sold
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.PaymentNFT.Sender">
            <summary>
            Sender of the payment
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.PaymentNFT.OriginalPaymentTxId">
            <summary>
            Original payment hash (can be from different blockchain or payment method)
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.PaymentNFT.Matched">
            <summary>
            When payment match the NFT which was bought this is set
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.PaymentNFT.AlreadySoldItem">
            <summary>
            If you receive payment and NFT is already sold this is set to true
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.PaymentNFT.Returned">
            <summary>
            If this payment was returned because NFT is not available this will be set as true
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.PaymentNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.PaymentNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.PaymentNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.PaymentNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.PostNFT">
            <summary>
            Post NFT is common text NFT, for example for articles or kind of publishing news of blockchain
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.PostNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.PostNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.PostNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.PostNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.PostNFT.GetLastData">
            <summary>
            Get last data of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.PostNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.ProductNFT">
            <summary>
            Product NFT, used as base for orders or invoices
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.ProductNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ProductNFT.ProducerProfileNFT">
            <summary>
            Hash of the NFT profile of the producer of this product
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ProductNFT.Datasheet">
            <summary>
            Datasheet link or hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ProductNFT.UnitPrice">
            <summary>
            Price in USD per one Unit
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.ProductNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.ProductNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.ProductNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.ProductNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.ProfileNFT">
            <summary>
            Profile NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.ProfileNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>        
        </member>
        <member name="P:VEDriversLite.NFT.ProfileNFT.Age">
            <summary>
            Age of the entity
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ProfileNFT.Surname">
            <summary>
            Surname of the entity
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ProfileNFT.Nickname">
            <summary>
            Nickname of the entity
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ProfileNFT.ID">
            <summary>
            Other related ID of the entity
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ProfileNFT.RelationshipStatus">
            <summary>
            Relations status to other entity/entities
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.ProfileNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.ProfileNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.ProfileNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.ProfileNFT.GetLastData">
            <summary>
            Get last data of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.ProfileNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.ReceiptNFT">
            <summary>
            Receipt NFT
            Used for example for receipts for sold NFTs
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.ReceiptNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>        
        </member>
        <member name="P:VEDriversLite.NFT.ReceiptNFT.NFTUtxoTxId">
            <summary>
            original NFT hash which was sold
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ReceiptNFT.NFTUtxoIndex">
            <summary>
            original NFT index which was sold
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ReceiptNFT.Sender">
            <summary>
            Sender of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ReceiptNFT.Buyer">
            <summary>
            Buyer of the NFT
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ReceiptNFT.OriginalPaymentTxId">
            <summary>
            Original payment transaction hash
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ReceiptNFT.ReceiptFromPaymentUtxo">
            <summary>
            Receipt from the payment Utxo
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.ReceiptNFT.SoldPrice">
            <summary>
            Sold price for this NFT
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.ReceiptNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.ReceiptNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.ReceiptNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.ReceiptNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.NFT.Tags.Tag">
            <summary>
            Tag with rememered info about usage, etc.
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Tags.Tag.Name">
            <summary>
            Tag name
            </summary>        
        </member>
        <member name="P:VEDriversLite.NFT.Tags.Tag.Command">
            <summary>
            Command
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Tags.Tag.Color">
            <summary>
            Color of badge
            </summary>        
        </member>
        <member name="P:VEDriversLite.NFT.Tags.Tag.Description">
            <summary>
            Description
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Tags.Tag.Image">
            <summary>
            Image Link
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Tags.Tag.Count">
            <summary>
            Count of usage
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Tags.Tag.UseAsFastButton">
            <summary>
            Display in UI as fast option
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Tags.Tag.LastUse">
            <summary>
            Last date of usage
            </summary>
        </member>
        <member name="P:VEDriversLite.NFT.Tags.Tag.RelatedTags">
            <summary>
            Related tags hashes list
            </summary>
        </member>
        <member name="T:VEDriversLite.NFT.TicketNFT">
            <summary>
            Ticket NFT. Should related to the NFT Event
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.TicketNFT.#ctor(System.String)">
            <summary>
            Create empty NFT class
            </summary>
        </member>
        <member name="M:VEDriversLite.NFT.TicketNFT.Fill(VEDriversLite.NFT.INFT)">
            <summary>
            Fill basic parameters
            </summary>
            <param name="NFT"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.TicketNFT.ParseSpecific(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse specific parameters
            </summary>
            <param name="metadata"></param>
        </member>
        <member name="M:VEDriversLite.NFT.TicketNFT.ParseOriginData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Find and parse origin data
            </summary>
            <param name="lastmetadata"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.TicketNFT.GetLastData">
            <summary>
            Get last data of this NFT
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.TicketNFT.LoadEventNFT">
            <summary>
            Get last data for the Event NFT related to this NFT Ticket
            </summary>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.NFT.TicketNFT.GetMetadata(System.String,System.String,System.String)">
            <summary>
            Get the NFT data for the NFT
            </summary>
            <param name="address">Address of the sender</param>
            <param name="key">Private key of the sender for encryption</param>
            <param name="receiver">receiver of the NFT</param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Security.ECDSAProvider">
            <summary>
            Provider of the ECDSA encryption, signatures, verifications, etc.
            </summary>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.VerifyDogeMessage(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Verify the Dogecoin message signed by some dogecoin private key
            </summary>
            <param name="message">input original message</param>
            <param name="signature">signature made by some dogecoin address</param>
            <param name="address">Dogecoin address</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.VerifyMessage(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Verify the Neblio message signed by some Neblio private key
            </summary>
            <param name="message">input original message</param>
            <param name="signature">signature made by some Neblio address</param>
            <param name="address">Neblio address</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.VerifyMessage(System.String,System.String,NBitcoin.PubKey,System.Boolean)">
            <summary>
            Verify the Neblio message signed by some Neblio Private Key.
            This function uses the Public Key instead of the Address for the verification
            </summary>
            <param name="message">input original message</param>
            <param name="signature">signature made by some Neblio address</param>
            <param name="address">Neblio address</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.SignMessage(System.String,System.String)">
            <summary>
            Sign the Message with Neblio Private Key
            </summary>
            <param name="message">Message to sign</param>
            <param name="privateKey">Neblio Private Key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.SignMessage(System.String,NBitcoin.BitcoinSecret)">
            <summary>
            Sign the Message with Neblio Private Key
            </summary>
            <param name="message">Message to sign</param>
            <param name="secret">Neblio Private Key in form of the BitcoinSecret</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.DecryptMessage(System.String,System.String)">
            <summary>
            Decrypt the message with use of the Neblio Private Key
            </summary>
            <param name="cryptedMessage">Encrypted Message to decrypt</param>
            <param name="privateKey">Neblio Private Key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.DecryptMessage(System.String,NBitcoin.BitcoinSecret)">
            <summary>
            Decrypt the message with use of the Neblio Private Key
            </summary>
            <param name="cryptedMessage">Encrypted Message to decrypt</param>
            <param name="secret">Neblio Private Key in form of BitcoinSecret</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.EncryptMessage(System.String,System.String)">
            <summary>
            Encrypt the message with use of Public Key
            </summary>
            <param name="message">Message to encrypt</param>
            <param name="publicKey">Public Key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.EncryptMessage(System.String,NBitcoin.PubKey)">
            <summary>
            Encrypt the message with use of Public Key
            </summary>
            <param name="message">Message to encrypt</param>
            <param name="publicKey">Public Key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.GetSharedSecret(System.String,System.String,NBitcoin.PubKey)">
            <summary>
            Obtain the Shared secret based on the Neblio Address and Neblio Private Key
            </summary>
            <param name="bobAddress">Neblio Address of the receiver</param>
            <param name="key">Private Key of the sender</param>
            <param name="bobPublicKey">Bob public key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.GetSharedSecret(System.String,NBitcoin.BitcoinSecret,NBitcoin.PubKey)">
            <summary>
            Obtain the Shared secret based on the Neblio Address and Neblio Private Key
            </summary>
            <param name="bobAddress">Neblio Address of the receiver</param>
            <param name="secret">Private Key of the sender in the form of the BitcoinSecret</param>
            <param name="bobPublicKey">Bob public key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.EncryptStringWithSharedSecret(System.String,System.String,System.String,System.String)">
            <summary>
            Encrypt the string with Shared secret
            </summary>
            <param name="message">Message to encrypt</param>
            <param name="bobAddress">Receiver Neblio Address</param>
            <param name="key">Neblio Private Key of the Sender</param>
            <param name="sharedkey">Shared key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.EncryptStringWithSharedSecret(System.String,System.String,NBitcoin.BitcoinSecret,System.String)">
            <summary>
            Encrypt the string with Shared secret
            </summary>
            <param name="message">Message to encrypt</param>
            <param name="bobAddress">Receiver Neblio Address</param>
            <param name="secret">Alice secret</param>
            <param name="sharedkey">shared key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.EncryptBytesWithSharedSecret(System.Byte[],System.String,NBitcoin.BitcoinSecret,System.String)">
            <summary>
            Encrypt the bytes with Shared secret
            </summary>
            <param name="inputBytes">Array of the bytes to encrypt</param>
            <param name="bobAddress">Receiver Neblio Address</param>
            <param name="secret">Neblio Private Key of the Sender in the form of BitcoinSecret</param>
            <param name="sharedkey">shared key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.EncryptStringWithSharedSecretWithKey(System.String,System.String,System.String)">
            <summary>
            Encrypt the string with Shared secret
            </summary>
            <param name="message">Message to encrypt</param>
            <param name="bobAddress">Receiver Neblio Address</param>
            <param name="key">Shared secret key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.DecryptStringWithSharedSecret(System.String,System.String,System.String)">
            <summary>
            Decrypt the string with Shared secret
            </summary>
            <param name="emessage">Message to decrypt</param>
            <param name="bobAddress">Receiver Neblio Address</param>
            <param name="key">Shared secret key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.DecryptStringWithSharedSecret(System.String,System.String,NBitcoin.BitcoinSecret,System.String)">
            <summary>
            Decrypt the string with Shared secret
            </summary>
            <param name="emessage">Message to decrypt</param>
            <param name="bobAddress">Receiver Neblio Address</param>
            <param name="secret">Neblio Private Key in form of the BitcoinSecret</param>
            <param name="sharedkey">Shared key from some previous call</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.DecryptBytesWithSharedSecret(System.Byte[],System.String,NBitcoin.BitcoinSecret,System.String)">
            <summary>
            Decrypt the bytes with Shared secret
            </summary>
            <param name="ebytes">Array of the bytes to decrypt</param>
            <param name="bobAddress">Receiver Neblio Address</param>
            <param name="secret">Neblio Private Key of the Sender in the form of BitcoinSecret</param>
            <param name="sharedkey">Shared key from some previous call</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.DecryptStringWithSharedSecretWithKey(System.String,System.String,System.String)">
            <summary>
            Dencrypt the string with Shared secret
            </summary>
            <param name="emessage">Message to decrypt</param>
            <param name="bobAddress">Receiver Neblio Address</param>
            <param name="key">Shared secret key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.DecryptStringWithPrivateKey(System.String,NBitcoin.Key)">
            <summary>
            
            </summary>
            <param name="encryptedText"></param>
            <param name="privateKey"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.DecryptBytesWithPrivateKey(System.Byte[],NBitcoin.Key)">
            <summary>
            
            </summary>
            <param name="encrypted"></param>
            <param name="privateKey"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.EncryptStringWithPublicKey(System.String,NBitcoin.PubKey)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.EncryptBytesWithPublicKey(System.Byte[],NBitcoin.PubKey)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VEDriversLite.Security.ECDSAProvider.HMACSHA256(System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:VEDriversLite.Security.EncryptionKey">
            <summary>
            Key container for the store of the key
            </summary>
        </member>
        <member name="M:VEDriversLite.Security.EncryptionKey.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor to load the key
            </summary>
            <param name="key">key in raw form. If it is already encrypted please set fromDb flag</param>
            <param name="password">password to encrypt the key during the load to this container</param>
            <param name="fromDb">if this is set it will not encrypt the key with the provided password and just store key as it is. Pass must be loaded separately</param>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.Id">
            <summary>
            ID of this key
            </summary>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.RelatedItemId">
            <summary>
            Related item ID
            </summary>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.Name">
            <summary>
            Name of the key
            </summary>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.PublicKey">
            <summary>
            Public key if there is some
            </summary>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.PasswordHash">
            <summary>
            Password hash
            </summary>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.IsEncrypted">
            <summary>
            Is the key encrypted flag
            </summary>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.Version">
            <summary>
            Version of the key
            </summary>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.Deleted">
            <summary>
            was key deleted
            </summary>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.IsLoaded">
            <summary>
            Is key loaded? Returns true if the key is not empty or null
            </summary>
        </member>
        <member name="P:VEDriversLite.Security.EncryptionKey.IsPassLoaded">
            <summary>
            Is pass loaded? Returns true if the pass is loaded
            </summary>
        </member>
        <member name="M:VEDriversLite.Security.EncryptionKey.GetEncryptedKey(System.String,System.Boolean)">
            <summary>
            This is confusing, sorry will be renamed soon
            It returns decrypted key if the pass is loaded. 
            If the pass is not loaded you need to provide pass
            If you want encrypted form of the key select returnEncrypted=true
            </summary>
            <param name="password">fill if the pass is not loaded and you need decrypted key</param>
            <param name="returnEncrypted">set true for return enrcypted form of key</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.EncryptionKey.LoadNewKey(System.String,System.String,System.Boolean)">
            <summary>
            Load the key and password.
            Same logic as constructor of this class
            </summary>
            <param name="key"></param>
            <param name="password"></param>
            <param name="fromDb"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.EncryptionKey.Lock">
            <summary>
            Lock the account. It will remove the loaded password and set passwordloaded flag to false
            </summary>
        </member>
        <member name="M:VEDriversLite.Security.EncryptionKey.LoadPassword(System.String)">
            <summary>
            Load the password to the container
            It will set passwordLoaded flag to true
            </summary>
            <param name="password"></param>
        </member>
        <member name="T:VEDriversLite.Security.SecurityUtils">
            <summary>
            Helper class for security
            </summary>
        </member>
        <member name="M:VEDriversLite.Security.SecurityUtils.IsBase64String(System.String)">
            <summary>
            Returns true if the string is the base64 string
            </summary>
            <param name="base64"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.SecurityUtils.ComputeSha256Hash(System.String)">
            <summary>
            Compute SHA256 Hash
            </summary>
            <param name="rawData"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.SymetricProvider.EncryptString(System.String,System.String)">
            <summary>
            Symmetrical encryption of the text.
            </summary>
            <param name="key">Password for the encryption</param>
            <param name="plainText">Text which should be encrypted</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.SymetricProvider.DecryptString(System.String,System.String)">
            <summary>
            Symmetrical decryption of the text
            </summary>
            <param name="key">Password for the encryption</param>
            <param name="cipherText">Text which should be decrypted</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.SymetricProvider.EncryptBytes(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Symmetrical encryption of the bytes
            </summary>
            <param name="key">Password for the encryption</param>
            <param name="bytes">Bytes array which should be encrypted</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.Security.SymetricProvider.DecryptBytes(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Symmetrical decryption of the bytes
            </summary>
            <param name="key">Password for the encryption</param>
            <param name="bytes">Bytes array which should be decrypted</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.IClient.GetAddressDetailsAsync(System.String)">
            <summary>Returns the Details of Unstoppable Domain address</summary>
            <param name="address">Crypto address</param>
            <returns>Object containing address details, empty object is returned.</returns>
            <exception cref="T:VEDriversLite.UnstoppableDomains.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.IClient.GetAddressDetailsAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Returns the address details from the Unstoppable Domain API
            </summary>
            <param name="address"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.Client.GetAddressDetailsAsync(System.String)">
            <summary>Returns the doge balance</summary>
            <param name="address">Doge address</param>
            <returns>Object containing doge balance, if address symbol does not exist on network, empty object is returned.</returns>
            <exception cref="T:VEDriversLite.UnstoppableDomains.ApiException">A server side error occurred.</exception>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.Client.GetAddressDetailsAsync(System.String,System.Threading.CancellationToken)">
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
            <summary>Returns the doge balance</summary>
            <param name="address">Doge address</param>
            <returns>Object containing doge balance, if address symbol does not exist on network, empty object is returned.</returns>
            <exception cref="T:VEDriversLite.UnstoppableDomains.ApiException">A server side error occurred.</exception>
        </member>
        <member name="P:VEDriversLite.UnstoppableDomains.GetAddressDetailsResponse.Addresses">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.UnstoppableDomains.GetAddressDetailsResponse.IPFS">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.UnstoppableDomains.GetAddressDetailsResponse.Records">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.UnstoppableDomains.GetAddressDetailsResponse.Meta">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.UnstoppableDomains.GetAddressDetailsResponse.Social">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.UnstoppableDomains.GetAddressDetailsResponse.MultiCoinAddresses">
            <summary>Success flag</summary>
        </member>
        <member name="P:VEDriversLite.UnstoppableDomains.GetAddressDetailsResponse.WhoIs">
            <summary>Success flag</summary>
        </member>
        <member name="T:VEDriversLite.UnstoppableDomains.UnstoppableDomainsHelpers">
            <summary>
            Helper class for obtain and parse data from UnstoppableDomains.com API
            </summary>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.UnstoppableDomainsHelpers.GetAddressDetails(System.String)">
            <summary>
            Load the information from the Unstoppable Domains API
            </summary>
            <param name="uAddress">UnstoppableDomain address - like "something.crypto"</param>
            <returns></returns>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.UnstoppableDomainsHelpers.GetNeblioAddress(System.String)">
            <summary>
            Get Neblio Address if exists
            </summary>
            <param name="uAddress">UnstoppableDomain address - like "something.crypto"</param>
            <returns>Address if exists, string.Empty if not exists</returns>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.UnstoppableDomainsHelpers.GetBTCAddress(System.String)">
            <summary>
            Get BTC Address if exists
            </summary>
            <param name="uAddress">UnstoppableDomain address - like "something.crypto"</param>
            <returns>Address if exists, string.Empty if not exists</returns>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.UnstoppableDomainsHelpers.GetETHAddress(System.String)">
            <summary>
            Get ETH Address if exists
            </summary>
            <param name="uAddress">UnstoppableDomain address - like "something.crypto"</param>
            <returns>Address if exists, string.Empty if not exists</returns>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.UnstoppableDomainsHelpers.GetLTCAddress(System.String)">
            <summary>
            Get LTC Address if exists
            </summary>
            <param name="uAddress">UnstoppableDomain address - like "something.crypto"</param>
            <returns>Address if exists, string.Empty if not exists</returns>
        </member>
        <member name="M:VEDriversLite.UnstoppableDomains.UnstoppableDomainsHelpers.GetDOGEAddress(System.String)">
            <summary>
            Get DOGE Address if exists
            </summary>
            <param name="uAddress">UnstoppableDomain address - like "something.crypto"</param>
            <returns>Address if exists, string.Empty if not exists</returns>
        </member>
        <member name="T:VEDriversLite.VEDLDataContext">
            <summary>
            Main shared data context
            </summary>
        </member>
        <member name="F:VEDriversLite.VEDLDataContext.Accounts">
            <summary>
            List of all Neblio Accounts
            </summary>
        </member>
        <member name="F:VEDriversLite.VEDLDataContext.DogeAccounts">
            <summary>
            List of all Dogecoin accounts
            </summary>
        </member>
        <member name="F:VEDriversLite.VEDLDataContext.AdminAddresses">
            <summary>
            Allowed addresses which can do some admin actions with AccountHandler
            </summary>
        </member>
        <member name="F:VEDriversLite.VEDLDataContext.PublicAddresses">
            <summary>
            Public addresses list.
            </summary>
        </member>
        <member name="F:VEDriversLite.VEDLDataContext.AdminActionsRequests">
            <summary>
            List of requested admin actions
            </summary>
        </member>
        <member name="F:VEDriversLite.VEDLDataContext.NFTHashs">
            <summary>
            NFT Hashes list. Usually it should contains list of all available NFTs in your app
            It should just speed up the testing
            </summary>
        </member>
        <member name="F:VEDriversLite.VEDLDataContext.NFTCache">
            <summary>
            Public list of the NFT Cache
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.AllowCache">
            <summary>
            If you will set this in you can control cache in you app. It is not implemented in the main logic of the App, just you can use it as common flag
            Example use is in VENFT App in omponent UnlockingAccount.razor
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.MaxCachedItems">
            <summary>
            Maximum items in the Cache dictionary
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.WooCommerceStoreUrl">
            <summary>
            Woo Commerce URL of your store
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.WooCommerceStoreUrlWithCred">
            <summary>
            If you use credentials inside of the WooCommerce API requests it is created here automatically - usually do not work with cors
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.WooCommerceStoreAPIKey">
            <summary>
            WooCommerce API key - you can obtain this key in the admin section of the WooCommerce
            Please install the WoC API plugin to enable this in the WoC
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.WooCommerceStoreSecret">
            <summary>
            WooCommerce API secret - you can obtain this key in the admin section of the WooCommerce
            Please install the WoC API plugin to enable this in the WoC
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.WooCommerceStoreJWTToken">
            <summary>
            If you will install the JWT plugin in the WordPress the JWT token can be stored here. 
            It should be obtained automatically after setup the login and pass
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.WooCommerceStoreCheckoutFieldCustomerNeblioAddress">
            <summary>
            This is the name of the Neblio Address field in the checkout form in WoC
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.WooCommerceStoreSendDogeToAuthor">
            <summary>
            If this is set, shop will send automatically the dogecoin to author based on selected deposit scheme
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.AllowDispatchNFTOrders">
            <summary>
            Allow to dispatch orders of NFTs automatically
            </summary>
        </member>
        <member name="P:VEDriversLite.VEDLDataContext.DepositSchemes">
            <summary>
            List of the deposit schemes for processing the payments for NFTs
            </summary>
        </member>
    </members>
</doc>
