# NFT ASL - API Settings Language
# version: 0.1
# Example comment

# address network
network neblio
# address to watch
address NWpT6Wiri9ZAsjVSH8m7eX85Nthqa2J8aY 
# process nfts which came just from specific receiver to observed address
just_from_receiver NQFkjSdYWWwPGFE8kQD4toCYkmddXiNh8W
# search just through specific tokens
just_tokens La58e9EeXUMx41uyfqk6kgVWAQq9yBs44nuQW8
# search just through specific type, types based on the VEFramework.VEDriversLite NFT Types Enum, can be add more separated by ','
nft_type NFTIoTMessages

# when 1 it starts asap, 0 and minus values are reserved, utc unix epoch time
start_provide time/1 
# duration of running this API command in hours
duration 100h 
# relation to the bufferplan
bufferplan nfttxid

# definition of result object
# each object is in the dictionary with key txid because it is unique
result one/dict {
	descriptor:num/txid/time
	# your name of item and data inside of the nft or json in description of the NFT
	item1name:nft.name
	item2name:nft.description.data.sensor.thermometer.temperature
	item3name:nft.description.data.tracking.latitude
	item4name:nft.description.data.tracking.longitude
	# new variables which will be added and you can work with them later
	item5name:new.sum_of_all
	# if something starts with the prev. it means it is related to the previous value in the list
	item6name:new.prevdiff 
	# if variable starts with the "is" it is bool - means true or false value
	item7name:new.isbigger 
}

# NOT IMPLEMENTED YET - if you set 0 it is maximum limit: from - newest, to - oldest
from 0/txid/time/blockheight/valuenamecondition to 0/count/txid/time/blockheight/valuenamecondition/exit
	# this will calculate and store actual value of sum of all previous items in messages
	new.sum_of_all = sum_of_all(item1name,x) 
	# this will calculate the difference between actual value and value of previous message item
	new.prevdiff = prev_diff(item1name) 
	# set flag if it is bigger
	new.prevdiff > 0 ? new.isbigger = true : new.isbigger = false
	new.prevdiff > new.prevdiv*100 ? exit_loop
end_loop

# NOT IMPLEMENTED YET - "for "to" loop can be replaced with this also
last 100 # means last 100 of items
	# this will calculate and store actual value of sum of all previous items in messages
	new.sum_of_all = sum_of_all(item1name) 
	# this will calculate the difference between actual value and value of previous message item
	new.prevdiff = prev_diff(item1name) 
	# set flag if it is bigger
    new.prevdiff > 0 ? new.isbigger = true : new.isbigger = false
	# in_max_iterations is custom variable which is recquired as input for the request
	actual_iteration > in_max_iterations ? exit_loop 
end_loop

# NOT IMPLEMENTED YET - or this kind of loop
first 100 # means first 100 of items
	# this will calculate and store actual value of sum of all previous items in messages
	new.sum_of_all = sum_of_all(item1name,x)
	# this will calculate the difference between actual value and value of previous message item
	new.prevdiff = prev_diff(item1name)
	# set flag if it is bigger
    new.prevdiff > 0 ? new.isbigger = true : new.isbigger = false
end_loop

# print result object line per line
print_result()
# order dictionary by item ascending (first/smallest is on top of the dictionary = A to Z, 1 to 9)
sortlist_1to9(item1name)
# order dictionary by item descending (last/largest is on top of the dictionary = Z to A, 9 to 1)
sortlist_9to1(item1name)


# NOT IMPLEMENTED YET - this will take all items in dict and multiply the item1name with x
multiply_all(item1name,x)
# NOT IMPLEMENTED YET - this will take all items in dict and add to the item1name x
add_all(item1name,x)
# NOT IMPLEMENTED YET - this will take all items in dict and substract the x from item1name
sub_all(item1name,x)
# NOT IMPLEMENTED YET - this will take all items in dict and replace x the item1name with y
replace_all(item1name,x, y)
# NOT IMPLEMENTED YET - this will take all items in dict and trim the item1name with x
trim_all(item1name,x)

# NOT IMPLEMENTED YET 
# interpolate whole dict with specific function and number of steps
# means: if you have list with N items and do one step it will add one between each.
# You will get (i+1)*N + i number of items.
# function can be "linear" "cubic"
intrapolate_all(item1name,functiontype, steps)
# extrapolate whole dict with specific function and number of steps
extrapolate_all(item1name,functiontype, steps)

return result # end of the program

# math in loop
+= like in c#
-= like in c#
/= like in c#
*= like in c#







